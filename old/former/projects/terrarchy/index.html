<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini Civilization</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #34495e;
            --accent-color: #e67e22;
            --light-color: #ecf0f1;
            --dark-color: #1a2530;
            --success-color: #2ecc71;
            --danger-color: #e74c3c;
            --water-color: #3498db;
            --grass-color: #2ecc71;
            --mountain-color: #7f8c8d;
            --forest-color: #27ae60;
            --desert-color: #f1c40f;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--dark-color);
            color: var(--light-color);
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        header {
            background-color: var(--primary-color);
            padding: 1rem;
            text-align: center;
            border-bottom: 2px solid var(--accent-color);
        }

        .game-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .map-container {
            flex: 3;
            position: relative;
            overflow: hidden;
            padding: 1rem;
        }

        .game-map {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(10, 1fr);
            gap: 4px;
            height: 100%;
            width: 100%;
            max-height: calc(100vh - 140px);
        }

        .tile {
            background-color: var(--grass-color);
            border-radius: 4px;
            position: relative;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .tile:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
            z-index: 2;
        }

        .tile.selected {
            border: 2px solid white;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }

        .tile.water {
            background-color: var(--water-color);
        }

        .tile.mountain {
            background-color: var(--mountain-color);
        }

        .tile.forest {
            background-color: var(--forest-color);
        }

        .tile.desert {
            background-color: var(--desert-color);
        }

        .tile-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            z-index: 1;
        }

        .tile-owner {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 100%;
            height: 100%;
            opacity: 0.3;
            border-radius: 4px;
        }

        .tile-building {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 80%;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            z-index: 1;
        }

        .tile-units {
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            z-index: 2;
        }

        .sidebar {
            flex: 1;
            background-color: var(--secondary-color);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .resources-panel {
            display: flex;
            justify-content: space-between;
            margin-bottom: 1rem;
            padding: 0.5rem;
            background-color: var(--primary-color);
            border-radius: 4px;
        }

        .resource {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .resource-value {
            font-weight: bold;
        }

        .action-panel, .info-panel {
            background-color: var(--primary-color);
            border-radius: 4px;
            padding: 0.5rem;
            margin-bottom: 1rem;
        }

        .panel-title {
            text-align: center;
            margin-bottom: 0.5rem;
            color: var(--accent-color);
            border-bottom: 1px solid var(--accent-color);
            padding-bottom: 0.5rem;
        }

        .action-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
        }

        button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            background-color: #d35400;
            transform: translateY(-2px);
        }

        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }

        .info-content {
            font-size: 0.9rem;
        }

        .turn-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: auto;
            background-color: var(--primary-color);
            padding: 0.5rem;
            border-radius: 4px;
        }

        .alert {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 1rem;
            background-color: var(--accent-color);
            color: white;
            border-radius: 4px;
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .alert.show {
            opacity: 1;
        }

        .building-menu, .unit-menu {
            display: none;
            position: absolute;
            background-color: var(--primary-color);
            border: 1px solid var(--accent-color);
            border-radius: 4px;
            padding: 0.5rem;
            z-index: 5;
            width: 200px;
        }

        .menu-item {
            padding: 0.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            border-radius: 4px;
        }

        .menu-item:hover {
            background-color: var(--secondary-color);
        }

        .menu-item-icon {
            margin-right: 0.5rem;
            width: 24px;
            height: 24px;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
        }

        .tech-tree-panel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 80%;
            background-color: var(--primary-color);
            border-radius: 8px;
            z-index: 10;
            padding: 1rem;
            overflow-y: auto;
        }

        .tech-tree-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
        }

        .tech-item {
            background-color: var(--secondary-color);
            padding: 0.5rem;
            border-radius: 4px;
            opacity: 0.6;
            cursor: pointer;
        }

        .tech-item.available {
            opacity: 1;
            border: 1px solid var(--accent-color);
        }

        .tech-item.researched {
            background-color: var(--success-color);
        }

        .close-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: var(--danger-color);
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--primary-color);
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        .title {
            font-size: 3rem;
            margin-bottom: 2rem;
            color: var(--accent-color);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .subtitle {
            font-size: 1.5rem;
            margin-bottom: 2rem;
            text-align: center;
        }

        .start-button {
            padding: 1rem 2rem;
            font-size: 1.5rem;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .start-button:hover {
            background-color: #d35400;
            transform: translateY(-4px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .instructions {
            margin-top: 2rem;
            background-color: var(--secondary-color);
            padding: 1rem;
            border-radius: 4px;
            max-width: 600px;
            text-align: left;
        }

        .instructions h2 {
            text-align: center;
            margin-bottom: 1rem;
            color: var(--accent-color);
        }

        /* AI opponents display */
        .ai-status {
            margin-top: 1rem;
            background-color: var(--primary-color);
            border-radius: 4px;
            padding: 0.5rem;
        }

        .ai-opponent {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .ai-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }

        .victory-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 20;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            color: white;
        }

        .victory-title {
            font-size: 4rem;
            margin-bottom: 2rem;
            color: gold;
            text-shadow: 0 0 10px gold;
        }

        .victory-message {
            font-size: 1.5rem;
            margin-bottom: 2rem;
            text-align: center;
        }

        .victory-stats {
            background-color: var(--primary-color);
            padding: 1rem;
            border-radius: 4px;
            margin-bottom: 2rem;
            width: 300px;
        }

        .replay-button {
            padding: 1rem 2rem;
            font-size: 1.5rem;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .replay-button:hover {
            background-color: #d35400;
            transform: translateY(-4px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <div id="start-screen">
        <h1 class="title">Mini Civilization</h1>
        <p class="subtitle">Build your empire, expand your territory, and conquer your enemies!</p>
        <button class="start-button" id="start-game">Start New Game</button>
        <div class="instructions">
            <h2>How to Play</h2>
            <p>1. Click on a tile to select it</p>
            <p>2. Build cities to generate gold and expand your territory</p>
            <p>3. Construct buildings to boost your empire's production and research</p>
            <p>4. Train units to defend your cities and conquer new lands</p>
            <p>5. Research technologies to unlock new buildings and units</p>
            <p>6. End your turn to progress the game</p>
            <p>7. Defeat all enemy civilizations to win!</p>
        </div>
    </div>

    <header>
        <h1>Mini Civilization</h1>
    </header>
    
    <div class="game-container">
        <div class="map-container">
            <div class="game-map" id="game-map"></div>
        </div>
        
        <div class="sidebar">
            <div class="resources-panel">
                <div class="resource">
                    <span>Gold</span>
                    <span class="resource-value" id="gold-value">0</span>
                </div>
                <div class="resource">
                    <span>Food</span>
                    <span class="resource-value" id="food-value">0</span>
                </div>
                <div class="resource">
                    <span>Production</span>
                    <span class="resource-value" id="production-value">0</span>
                </div>
                <div class="resource">
                    <span>Science</span>
                    <span class="resource-value" id="science-value">0</span>
                </div>
            </div>
            
            <div class="action-panel">
                <h3 class="panel-title">Actions</h3>
                <div class="action-buttons">
                    <button id="build-city-btn" disabled>Build City (100)</button>
                    <button id="build-btn" disabled>Build</button>
                    <button id="train-unit-btn" disabled>Train Unit</button>
                    <button id="move-unit-btn" disabled>Move Unit</button>
                    <button id="attack-btn" disabled>Attack</button>
                    <button id="tech-btn">Research</button>
                </div>
            </div>
            
            <div class="info-panel">
                <h3 class="panel-title">Information</h3>
                <div class="info-content" id="info-content">
                    Select a tile to see information.
                </div>
            </div>

            <div class="ai-status">
                <h3 class="panel-title">AI Opponents</h3>
                <div id="ai-list"></div>
            </div>
            
            <div class="turn-panel">
                <div>
                    <span>Turn: </span>
                    <span id="turn-counter">1</span>
                </div>
                <button id="end-turn-btn">End Turn</button>
            </div>
        </div>
    </div>

    <div class="building-menu" id="building-menu">
        <div class="menu-item" data-building="farm">
            <div class="menu-item-icon" style="background-image: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><rect x=\"2\" y=\"8\" width=\"20\" height=\"14\" fill=\"%23795548\"/><rect x=\"4\" y=\"12\" width=\"16\" height=\"10\" fill=\"%238D6E63\"/><rect x=\"8\" y=\"2\" width=\"8\" height=\"6\" fill=\"%23A1887F\"/><rect x=\"10\" y=\"2\" width=\"4\" height=\"10\" fill=\"%23795548\"/></svg>');"></div>
            <span>Farm (50🔨) +2 Food</span>
        </div>
        <div class="menu-item" data-building="mine">
            <div class="menu-item-icon" style="background-image: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M2,22 L22,22 L12,2 L2,22 Z\" fill=\"%23757575\"/><path d=\"M8,16 L16,16 L12,6 L8,16 Z\" fill=\"%23424242\"/></svg>');"></div>
            <span>Mine (50🔨) +2 Production</span>
        </div>
        <div class="menu-item" data-building="market">
            <div class="menu-item-icon" style="background-image: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><rect x=\"2\" y=\"4\" width=\"20\" height=\"16\" fill=\"%23FFC107\"/><path d=\"M2,8 L22,8\" stroke=\"%23795548\" stroke-width=\"2\"/><path d=\"M6,4 L6,20\" stroke=\"%23795548\" stroke-width=\"2\"/><path d=\"M12,4 L12,20\" stroke=\"%23795548\" stroke-width=\"2\"/><path d=\"M18,4 L18,20\" stroke=\"%23795548\" stroke-width=\"2\"/></svg>');"></div>
            <span>Market (75🔨) +3 Gold</span>
        </div>
        <div class="menu-item" data-building="library">
            <div class="menu-item-icon" style="background-image: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><rect x=\"2\" y=\"4\" width=\"20\" height=\"16\" fill=\"%233F51B5\"/><rect x=\"5\" y=\"7\" width=\"3\" height=\"10\" fill=\"%23C5CAE9\"/><rect x=\"10\" y=\"7\" width=\"3\" height=\"10\" fill=\"%23C5CAE9\"/><rect x=\"15\" y=\"7\" width=\"3\" height=\"10\" fill=\"%23C5CAE9\"/></svg>');"></div>
            <span>Library (75🔨) +3 Science</span>
        </div>
        <div class="menu-item" data-building="barracks">
            <div class="menu-item-icon" style="background-image: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><rect x=\"3\" y=\"6\" width=\"18\" height=\"12\" fill=\"%23795548\"/><path d=\"M3,6 L12,2 L21,6\" fill=\"%238D6E63\"/><rect x=\"8\" y=\"10\" width=\"8\" height=\"8\" fill=\"%23A1887F\"/></svg>');"></div>
            <span>Barracks (100🔨) Military</span>
        </div>
    </div>

    <div class="unit-menu" id="unit-menu">
        <div class="menu-item" data-unit="warrior">
            <div class="menu-item-icon" style="background-image: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><circle cx=\"12\" cy=\"8\" r=\"6\" fill=\"%23FFC107\"/><rect x=\"10\" y=\"14\" width=\"4\" height=\"8\" fill=\"%23795548\"/><rect x=\"6\" y=\"14\" width=\"12\" height=\"2\" fill=\"%23795548\"/></svg>');"></div>
            <span>Warrior (50🔨) A:2 D:2</span>
        </div>
        <div class="menu-item" data-unit="archer">
            <div class="menu-item-icon" style="background-image: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><circle cx=\"12\" cy=\"8\" r=\"6\" fill=\"%234CAF50\"/><rect x=\"11\" y=\"7\" width=\"2\" height=\"12\" fill=\"%23795548\"/><path d=\"M10,10 L14,10 L12,18 Z\" fill=\"%23795548\"/></svg>');"></div>
            <span>Archer (60🔨) A:3 D:1</span>
        </div>
        <div class="menu-item" data-unit="swordsman">
            <div class="menu-item-icon" style="background-image: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><circle cx=\"12\" cy=\"7\" r=\"5\" fill=\"%23F44336\"/><path d=\"M9,12 L15,12 L15,20 L9,20 Z\" fill=\"%23BDBDBD\"/><rect x=\"11\" y=\"20\" width=\"2\" height=\"2\" fill=\"%239E9E9E\"/></svg>');"></div>
            <span>Swordsman (80🔨) A:4 D:2</span>
        </div>
        <div class="menu-item" data-unit="knight">
            <div class="menu-item-icon" style="background-image: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M4,18 L20,18 L17,5 L7,5 Z\" fill=\"%239E9E9E\"/><circle cx=\"12\" cy=\"10\" r=\"4\" fill=\"%23757575\"/><path d=\"M8,20 L16,20 L16,18 L8,18 Z\" fill=\"%23424242\"/></svg>');"></div>
            <span>Knight (100🔨) A:5 D:3</span>
        </div>
        <div class="menu-item" data-unit="settler">
            <div class="menu-item-icon" style="background-image: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><circle cx=\"12\" cy=\"10\" r=\"5\" fill=\"%23CDDC39\"/><path d=\"M7,18 L17,18 L17,15 L7,15 Z\" fill=\"%23FFEB3B\"/><path d=\"M10,15 L14,15 L12,13 Z\" fill=\"%23FFC107\"/></svg>');"></div>
            <span>Settler (100🔨) Found City</span>
        </div>
    </div>

    <div class="tech-tree-panel" id="tech-tree-panel">
        <div class="close-button" id="close-tech">✕</div>
        <h2 class="panel-title">Technology Tree</h2>
        <div class="tech-tree-container" id="tech-tree-container">
            <!-- Techs will be added dynamically -->
        </div>
    </div>

    <div class="victory-screen" id="victory-screen">
        <h1 class="victory-title">Victory!</h1>
        <p class="victory-message">You have conquered the world and established your dominance!</p>
        <div class="victory-stats">
            <p>Turns: <span id="final-turns">0</span></p>
            <p>Cities Built: <span id="final-cities">0</span></p>
            <p>Units Trained: <span id="final-units">0</span></p>
            <p>Enemies Defeated: <span id="final-enemies">0</span></p>
        </div>
        <button class="replay-button" id="replay-button">Play Again</button>
    </div>

    <div class="alert" id="alert"></div>

    <script>
        // Game State
        const gameState = {
            turn: 1,
            selectedTile: null,
            tiles: [],
            players: [
                { id: 0, name: "Player", color: "#e74c3c", gold: 100, food: 0, production: 0, science: 0, alive: true },
                { id: 1, name: "AI 1", color: "#3498db", gold: 100, food: 0, production: 0, science: 0, alive: true },
                { id: 2, name: "AI 2", color: "#2ecc71", gold: 100, food: 0, production: 0, science: 0, alive: true }
            ],
            currentPlayer: 0,
            cityBuildCost: 100,
            technologies: [
                { id: 0, name: "Agriculture", cost: 20, unlocks: ["Farm"], dependencies: [], researched: true, description: "Enables farm buildings" },
                { id: 1, name: "Mining", cost: 20, unlocks: ["Mine"], dependencies: [], researched: true, description: "Enables mine buildings" },
                { id: 2, name: "Writing", cost: 30, unlocks: ["Library"], dependencies: [], researched: true, description: "Enables library buildings" },
                { id: 3, name: "Currency", cost: 40, unlocks: ["Market"], dependencies: [1], researched: false, description: "Enables market buildings" },
                { id: 4, name: "Bronze Working", cost: 40, unlocks: ["Swordsman"], dependencies: [1], researched: false, description: "Enables training swordsmen" },
                { id: 5, name: "Mathematics", cost: 60, unlocks: ["Archer"], dependencies: [2], researched: false, description: "Enables training archers" },
                { id: 6, name: "Iron Working", cost: 80, unlocks: ["Barracks"], dependencies: [4], researched: false, description: "Enables barracks buildings" },
                { id: 7, name: "Horseback Riding", cost: 100, unlocks: ["Knight"], dependencies: [4], researched: false, description: "Enables training knights" }
            ],
            currentResearch: null,
            sciencePoints: 0,
            stats: {
                citiesBuilt: 0,
                unitsTrained: 0,
                enemiesDefeated: 0
            },
            moveState: null,
            attackState: null
        };

        // DOM Elements
        const gameMap = document.getElementById('game-map');
        const goldValue = document.getElementById('gold-value');
        const foodValue = document.getElementById('food-value');
        const productionValue = document.getElementById('production-value');
        const scienceValue = document.getElementById('science-value');
        const turnCounter = document.getElementById('turn-counter');
        const infoContent = document.getElementById('info-content');
        const buildCityBtn = document.getElementById('build-city-btn');
        const buildBtn = document.getElementById('build-btn');
        const trainUnitBtn = document.getElementById('train-unit-btn');
        const moveUnitBtn = document.getElementById('move-unit-btn');
        const attackBtn = document.getElementById('attack-btn');
        const techBtn = document.getElementById('tech-btn');
        const endTurnBtn = document.getElementById('end-turn-btn');
        const buildingMenu = document.getElementById('building-menu');
        const unitMenu = document.getElementById('unit-menu');
        const techTreePanel = document.getElementById('tech-tree-panel');
        const techTreeContainer = document.getElementById('tech-tree-container');
        const closeTechBtn = document.getElementById('close-tech');
        const startScreen = document.getElementById('start-screen');
        const startGameBtn = document.getElementById('start-game');
        const aiList = document.getElementById('ai-list');
        const victoryScreen = document.getElementById('victory-screen');
        const replayButton = document.getElementById('replay-button');
        const finalTurns = document.getElementById('final-turns');
        const finalCities = document.getElementById('final-cities');
        const finalUnits = document.getElementById('final-units');
        const finalEnemies = document.getElementById('final-enemies');
        const alertElement = document.getElementById('alert');

        // Helper functions
        function capitalizeFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

        function showAlert(message) {
            alertElement.textContent = message;
            alertElement.classList.add('show');
            
            setTimeout(() => {
                alertElement.classList.remove('show');
            }, 3000);
        }

        function updateResourceDisplay() {
            goldValue.textContent = gameState.players[0].gold;
            foodValue.textContent = gameState.players[0].food;
            productionValue.textContent = gameState.players[0].production;
            scienceValue.textContent = gameState.players[0].science;
        }

        function updateAIStatus() {
            aiList.innerHTML = '';
            
            for (let i = 1; i < gameState.players.length; i++) {
                const player = gameState.players[i];
                
                const aiElement = document.createElement('div');
                aiElement.classList.add('ai-opponent');
                
                const colorElement = document.createElement('div');
                colorElement.classList.add('ai-color');
                colorElement.style.backgroundColor = player.color;
                
                const nameElement = document.createElement('span');
                nameElement.textContent = player.name + (player.alive ? '' : ' (Defeated)');
                
                aiElement.appendChild(colorElement);
                aiElement.appendChild(nameElement);
                
                aiList.appendChild(aiElement);
            }
        }

        // Game Initialization
        function initializeGame() {
            // Create tiles
            createMap();
            
            // Update UI
            updateResourceDisplay();
            updateAIStatus();
            
            // Add event listeners
            endTurnBtn.addEventListener('click', endTurn);
            buildCityBtn.addEventListener('click', buildCity);
            buildBtn.addEventListener('click', showBuildingMenu);
            trainUnitBtn.addEventListener('click', showUnitMenu);
            moveUnitBtn.addEventListener('click', startMoveUnit);
            attackBtn.addEventListener('click', startAttack);
            techBtn.addEventListener('click', showTechTree);
            closeTechBtn.addEventListener('click', hideTechTree);
            
            // Building menu event delegation
            buildingMenu.addEventListener('click', (e) => {
                const menuItem = e.target.closest('.menu-item');
                if (menuItem) {
                    const buildingType = menuItem.dataset.building;
                    buildBuilding(buildingType);
                    hideBuildingMenu();
                }
            });
            
            // Unit menu event delegation
            unitMenu.addEventListener('click', (e) => {
                const menuItem = e.target.closest('.menu-item');
                if (menuItem) {
                    const unitType = menuItem.dataset.unit;
                    trainUnit(unitType);
                    hideUnitMenu();
                }
            });

            startGameBtn.addEventListener('click', () => {
                startScreen.style.display = 'none';
            });

            replayButton.addEventListener('click', () => {
                victoryScreen.style.display = 'none';
                resetGame();
            });
        }

        // Get unit image with player color
        function getUnitImage(unitType, playerId) {
            const playerColor = gameState.players[playerId].color.replace('#', '%23');
            
            switch(unitType) {
                case 'warrior':
                    return `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="12" cy="8" r="6" fill="${playerColor}"/><rect x="10" y="14" width="4" height="8" fill="%23795548"/><rect x="6" y="14" width="12" height="2" fill="%23795548"/></svg>')`;
                case 'archer':
                    return `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="12" cy="8" r="6" fill="${playerColor}"/><rect x="11" y="7" width="2" height="12" fill="%23795548"/><path d="M10,10 L14,10 L12,18 Z" fill="%23795548"/></svg>')`;
                case 'swordsman':
                    return `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="12" cy="7" r="5" fill="${playerColor}"/><path d="M9,12 L15,12 L15,20 L9,20 Z" fill="%23BDBDBD"/><rect x="11" y="20" width="2" height="2" fill="%239E9E9E"/></svg>')`;
                case 'knight':
                    return `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4,18 L20,18 L17,5 L7,5 Z" fill="%239E9E9E"/><circle cx="12" cy="10" r="4" fill="${playerColor}"/><path d="M8,20 L16,20 L16,18 L8,18 Z" fill="%23424242"/></svg>')`;
                case 'settler':
                    return `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="12" cy="10" r="5" fill="${playerColor}"/><path d="M7,18 L17,18 L17,15 L7,15 Z" fill="%23FFEB3B"/><path d="M10,15 L14,15 L12,13 Z" fill="%23FFC107"/></svg>')`;
                default:
                    return '';
            }
        }

        // Add CSS styles for improved tile graphics
function addTileGraphicsStyles() {
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        .tile.water {
            background-image: linear-gradient(45deg, #2980b9, #3498db);
            box-shadow: inset 0 0 10px rgba(41, 128, 185, 0.5);
        }
        
        .tile.forest {
            background-image: linear-gradient(to bottom, #27ae60, #2ecc71);
            box-shadow: inset 0 0 10px rgba(39, 174, 96, 0.5);
        }
        
        .tile.mountain {
            background-image: linear-gradient(to bottom, #6c7a89, #95a5a6);
            box-shadow: inset 0 0 10px rgba(108, 122, 137, 0.5);
        }
        
        .tile.desert {
            background-image: linear-gradient(to bottom, #f39c12, #f1c40f);
            box-shadow: inset 0 0 10px rgba(243, 156, 18, 0.5);
        }
        
        .tile.grass {
            background-image: linear-gradient(to bottom, #2ecc71, #27ae60);
            box-shadow: inset 0 0 10px rgba(46, 204, 113, 0.5);
        }
        
        .tile-texture {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.3;
            z-index: 0;
        }
    `;
    document.head.appendChild(styleElement);
}

// Add textures to tile when creating map
function addTileTexture(tile, tileType) {
    const textureElement = document.createElement('div');
    textureElement.classList.add('tile-texture');
    
    switch(tileType) {
        case 'water':
            textureElement.style.backgroundImage = `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M0,12 Q6,8 12,12 T24,12 T36,12 T48,12" stroke="%23FFFFFF" stroke-width="1" fill="none" opacity="0.3" transform="translate(0,0)"><animate attributeName="d" values="M0,12 Q6,8 12,12 T24,12 T36,12 T48,12;M0,12 Q6,16 12,12 T24,12 T36,12 T48,12;M0,12 Q6,8 12,12 T24,12 T36,12 T48,12" dur="5s" repeatCount="indefinite"/><animate attributeName="transform" values="translate(0,0); translate(-24,0); translate(0,0)" dur="5s" repeatCount="indefinite"/></path></svg>')`;
            textureElement.style.backgroundSize = '50px 50px';
            break;
        case 'forest':
            textureElement.style.backgroundImage = `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12,2 L16,10 L8,10 Z" fill="%23196F3D" opacity="0.4" transform="translate(0,0)"/><path d="M12,5 L16,13 L8,13 Z" fill="%23196F3D" opacity="0.4" transform="translate(6,3)"/><path d="M12,5 L16,13 L8,13 Z" fill="%23196F3D" opacity="0.4" transform="translate(-6,3)"/></svg>')`;
            textureElement.style.backgroundSize = '40px 40px';
            break;
        case 'mountain':
            textureElement.style.backgroundImage = `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M0,24 L12,2 L24,24 Z" fill="%23424242" opacity="0.2"/><path d="M4,24 L12,8 L20,24 Z" fill="%23424242" opacity="0.3"/></svg>')`;
            textureElement.style.backgroundSize = '40px 40px';
            break;
        case 'desert':
            textureElement.style.backgroundImage = `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="4" cy="4" r="1" fill="%23D68910" opacity="0.4"/><circle cx="12" cy="10" r="1" fill="%23D68910" opacity="0.4"/><circle cx="20" cy="18" r="1" fill="%23D68910" opacity="0.4"/><circle cx="16" cy="6" r="1" fill="%23D68910" opacity="0.4"/><circle cx="8" cy="14" r="1" fill="%23D68910" opacity="0.4"/></svg>')`;
            textureElement.style.backgroundSize = '20px 20px';
            break;
        case 'grass':
            textureElement.style.backgroundImage = `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M2,10 L4,12 L6,10" stroke="%231D8348" stroke-width="0.5" fill="none" opacity="0.2"/><path d="M10,18 L12,20 L14,18" stroke="%231D8348" stroke-width="0.5" fill="none" opacity="0.2"/><path d="M18,6 L20,8 L22,6" stroke="%231D8348" stroke-width="0.5" fill="none" opacity="0.2"/></svg>')`;
            textureElement.style.backgroundSize = '20px 20px';
            break;
    }
    
    tile.element.appendChild(textureElement);
}

// Update createMap function to include textures
function enhanceTileGraphics() {
    // First, add the CSS styles
    addTileGraphicsStyles();
    
    // Then, for each existing tile, add texture
    for (let y = 0; y < 10; y++) {
        for (let x = 0; x < 10; x++) {
            const tile = gameState.tiles[y][x];
            addTileTexture(tile.element, tile.type);
        }
    }
}

// Enhanced map generation function
function createImprovedMap() {
    // First, clear the map
    gameMap.innerHTML = '';
    gameState.tiles = [];
    
    // Map generation parameters
    const mapSize = 10;
    const waterPercentage = 0.2;
    const mountainPercentage = 0.15;
    const forestPercentage = 0.3;
    const desertPercentage = 0.15;
    
    // Create heightmap for more natural terrain
    const heightmap = generateHeightmap(mapSize);
    
    // Generate the map
    for (let y = 0; y < mapSize; y++) {
        gameState.tiles[y] = [];
        for (let x = 0; x < mapSize; x++) {
            // Create a tile element
            const tile = document.createElement('div');
            tile.classList.add('tile');
            
            // Determine tile type based on heightmap
            let tileType = 'grass';
            const height = heightmap[y][x];
            
            if (height < waterPercentage) {
                tileType = 'water';
                tile.classList.add('water');
            } else if (height > 1 - mountainPercentage) {
                tileType = 'mountain';
                tile.classList.add('mountain');
            } else if (height > 1 - mountainPercentage - forestPercentage) {
                tileType = 'forest';
                tile.classList.add('forest');
            } else if (height < waterPercentage + desertPercentage) {
                tileType = 'desert';
                tile.classList.add('desert');
            }
            
            // Create tile data
            const tileData = {
                x,
                y,
                type: tileType,
                owner: null,
                building: null,
                isCity: false,
                units: [],
                element: tile,
                fertility: calculateFertility(tileType, x, y)
            };
            
            // Store the tile data
            gameState.tiles[y][x] = tileData;
            
            // Add click event to select the tile
            tile.addEventListener('click', () => selectTile(x, y));
            
            // Add texture to the tile
            addTileTexture(tile, tileType);
            
            // Add the tile to the map
            gameMap.appendChild(tile);
        }
    }
    
    // Find suitable starting locations for players
    placeStartingLocations();
}

// Generate heightmap for natural terrain
function generateHeightmap(size) {
    // Initialize heightmap with random values
    let heightmap = [];
    for (let y = 0; y < size; y++) {
        heightmap[y] = [];
        for (let x = 0; x < size; x++) {
            heightmap[y][x] = Math.random();
        }
    }
    
    // Smooth the heightmap for more natural terrain
    for (let i = 0; i < 3; i++) {
        heightmap = smoothHeightmap(heightmap, size);
    }
    
    return heightmap;
}

// Smooth heightmap using neighbor averaging
function smoothHeightmap(heightmap, size) {
    const newHeightmap = [];
    
    for (let y = 0; y < size; y++) {
        newHeightmap[y] = [];
        for (let x = 0; x < size; x++) {
            let sum = heightmap[y][x];
            let count = 1;
            
            // Check neighbors
            const directions = [
                { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                { x: -1, y: 0 }, /* center */ { x: 1, y: 0 },
                { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }
            ];
            
            for (const dir of directions) {
                const newX = x + dir.x;
                const newY = y + dir.y;
                
                if (newX >= 0 && newX < size && newY >= 0 && newY < size) {
                    sum += heightmap[newY][newX];
                    count++;
                }
            }
            
            newHeightmap[y][x] = sum / count;
        }
    }
    
    return newHeightmap;
}

// Calculate fertility of a tile for starting location quality
function calculateFertility(tileType, x, y) {
    switch(tileType) {
        case 'grass': return 3;
        case 'forest': return 2;
        case 'desert': return 1;
        case 'water': return 0;
        case 'mountain': return 0;
        default: return 0;
    }
}

// Find and place suitable starting locations
function placeStartingLocations() {
    const mapSize = 10;
    const startingLocations = findSuitableStartingLocations(3); // For 3 players
    
    // Place starting cities for players
    placeStartingCity(0, startingLocations[0].x, startingLocations[0].y); // Player
    placeStartingCity(1, startingLocations[1].x, startingLocations[1].y); // AI 1
    placeStartingCity(2, startingLocations[2].x, startingLocations[2].y); // AI 2
}

// Find suitable starting locations for all players
function findSuitableStartingLocations(playerCount) {
    const mapSize = 10;
    const locations = [];
    
    // Evaluate each tile for suitability as starting location
    const locationScores = [];
    
    for (let y = 0; y < mapSize; y++) {
        for (let x = 0; x < mapSize; x++) {
            const tile = gameState.tiles[y][x];
            
            // Skip water and mountain tiles
            if (tile.type === 'water' || tile.type === 'mountain') continue;
            
            // Calculate score based on surrounding tiles
            let score = tile.fertility;
            
            // Check surrounding tiles for resources
            const directions = [
                { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                { x: -1, y: 0 }, /* center */ { x: 1, y: 0 },
                { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }
            ];
            
            for (const dir of directions) {
                const newX = x + dir.x;
                const newY = y + dir.y;
                
                if (newX >= 0 && newX < mapSize && newY >= 0 && newY < mapSize) {
                    const neighborTile = gameState.tiles[newY][newX];
                    score += neighborTile.fertility * 0.5;
                }
            }
            
            locationScores.push({ x, y, score });
        }
    }
    
    // Sort locations by score
    locationScores.sort((a, b) => b.score - a.score);
    
    // Get top locations with minimum distance from each other
    let selectedLocations = [locationScores[0]];
    
    for (let i = 1; i < locationScores.length && selectedLocations.length < playerCount; i++) {
        const candidate = locationScores[i];
        let isFarEnough = true;
        
        // Check distance from already selected locations
        for (const location of selectedLocations) {
            const distance = Math.abs(candidate.x - location.x) + Math.abs(candidate.y - location.y);
            if (distance < mapSize / 2) {
                isFarEnough = false;
                break;
            }
        }
        
        if (isFarEnough) {
            selectedLocations.push(candidate);
        }
    }
    
    // If we don't have enough locations, relax constraints
    if (selectedLocations.length < playerCount) {
        for (let i = 1; i < locationScores.length && selectedLocations.length < playerCount; i++) {
            const candidate = locationScores[i];
            
            // Skip if already selected
            if (selectedLocations.some(loc => loc.x === candidate.x && loc.y === candidate.y)) {
                continue;
            }
            
            selectedLocations.push(candidate);
        }
    }
    
    return selectedLocations.map(loc => ({ x: loc.x, y: loc.y }));
}


        
        // Create map
        function createMap() {
            // First, clear the map
            gameMap.innerHTML = '';
            gameState.tiles = [];
            
            // Generate a 10x10 map
            for (let y = 0; y < 10; y++) {
                gameState.tiles[y] = [];
                for (let x = 0; x < 10; x++) {
                    // Create a tile element
                    const tile = document.createElement('div');
                    tile.classList.add('tile');
                    
                    // Determine tile type
                    const rand = Math.random();
                    let tileType = 'grass';
                    
                    if (rand < 0.1) {
                        tileType = 'water';
                        tile.classList.add('water');
                    } else if (rand < 0.2) {
                        tileType = 'mountain';
                        tile.classList.add('mountain');
                    } else if (rand < 0.4) {
                        tileType = 'forest';
                        tile.classList.add('forest');
                    } else if (rand < 0.5) {
                        tileType = 'desert';
                        tile.classList.add('desert');
                    }
                    
                    // Create tile data
                    const tileData = {
                        x,
                        y,
                        type: tileType,
                        owner: null,
                        building: null,
                        isCity: false,
                        units: [],
                        element: tile
                    };
                    
                    // Store the tile data
                    gameState.tiles[y][x] = tileData;
                    
                    // Add click event to select the tile
                    tile.addEventListener('click', () => selectTile(x, y));
                    
                    // Add the tile to the map
                    gameMap.appendChild(tile);
                }
            }
            
            // Place starting cities for players
            placeStartingCity(0, 1, 1); // Player
            placeStartingCity(1, 8, 1); // AI 1
            placeStartingCity(2, 8, 8); // AI 2
        }
        
        // Place a starting city for a player
        function placeStartingCity(playerId, x, y) {
            const tile = gameState.tiles[y][x];
            
            // Mark as city
            tile.isCity = true;
            tile.owner = playerId;
            
            // Add city icon and color
            const cityIcon = document.createElement('div');
            cityIcon.classList.add('tile-building');
            cityIcon.style.backgroundImage = `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><rect x="2" y="10" width="20" height="12" fill="%23607D8B"/><rect x="4" y="6" width="16" height="4" fill="%2378909C"/><rect x="7" y="2" width="10" height="4" fill="%23B0BEC5"/><rect x="5" y="14" width="3" height="3" fill="%23CFD8DC"/><rect x="10" y="14" width="3" height="3" fill="%23CFD8DC"/><rect x="15" y="14" width="3" height="3" fill="%23CFD8DC"/><rect x="5" y="19" width="13" height="1" fill="%23B0BEC5"/></svg>')`;
            tile.element.appendChild(cityIcon);
            
            const ownerColor = document.createElement('div');
            ownerColor.classList.add('tile-owner');
            ownerColor.style.backgroundColor = gameState.players[playerId].color;
            tile.element.appendChild(ownerColor);
            
            // Claim adjacent tiles
            claimAdjacentTiles(x, y, playerId);
            
            // Increment stats
            if (playerId === 0) {
                gameState.stats.citiesBuilt++;
            }
        }
        
        // Claim adjacent tiles for a player
        function claimAdjacentTiles(x, y, playerId) {
            const directions = [
                { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                { x: -1, y: 0 }, /* center */ { x: 1, y: 0 },
                { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }
            ];
            
            for (const dir of directions) {
                const newX = x + dir.x;
                const newY = y + dir.y;
                
                // Skip if outside bounds
                if (newX < 0 || newX >= 10 || newY < 0 || newY >= 10) continue;
                
                const targetTile = gameState.tiles[newY][newX];
                
                // Skip water and mountain tiles
                if (targetTile.type === 'water' || targetTile.type === 'mountain') continue;
                
                // Skip enemy cities
                if (targetTile.isCity && targetTile.owner !== playerId) continue;
                
                // Skip tiles with enemy units
                if (targetTile.units.some(unit => unit.owner !== playerId)) continue;
                
                // Claim tile if unclaimed or if our culture is stronger
                if (targetTile.owner === null) {
                    targetTile.owner = playerId;
                    
                    // Add owner color
                    const ownerColor = document.createElement('div');
                    ownerColor.classList.add('tile-owner');
                    ownerColor.style.backgroundColor = gameState.players[playerId].color;
                    targetTile.element.appendChild(ownerColor);
                }
            }
        }
        
        // Select a tile
        function selectTile(x, y) {
            // Deselect previous tile
            if (gameState.selectedTile) {
                gameState.selectedTile.element.classList.remove('selected');
            }
            
            // Select new tile
            const tile = gameState.tiles[y][x];
            tile.element.classList.add('selected');
            gameState.selectedTile = tile;
            
            // Update info panel
            updateInfoPanel();
            
            // Update action buttons
            updateActionButtons();
        }
        
        // Update information panel with selected tile info
        function updateInfoPanel() {
            const tile = gameState.selectedTile;
            
            if (!tile) {
                infoContent.textContent = 'Select a tile to see information.';
                return;
            }
            
            let info = `<p>Terrain: ${capitalizeFirstLetter(tile.type)}</p>`;
            
            if (tile.owner !== null) {
                info += `<p>Owner: ${gameState.players[tile.owner].name}</p>`;
            } else {
                info += `<p>Unclaimed territory</p>`;
            }
            
            if (tile.isCity) {
                info += `<p>City</p>`;
            }
            
            if (tile.building) {
                info += `<p>Building: ${capitalizeFirstLetter(tile.building)}</p>`;
            }
            
            if (tile.units.length > 0) {
                info += `<p>Units: ${tile.units.map(u => u.type).join(', ')}</p>`;
            }
            
            infoContent.innerHTML = info;
        }
        
        // Update action buttons based on selected tile
        function updateActionButtons() {
            const tile = gameState.selectedTile;
            
            // Reset buttons
            buildCityBtn.disabled = true;
            buildBtn.disabled = true;
            trainUnitBtn.disabled = true;
            moveUnitBtn.disabled = true;
            attackBtn.disabled = true;
            
            if (!tile) return;
            
            // Only enable actions for player's tiles
            if (tile.owner === 0) {
                // Build city (only on empty tile with a settler unit)
                const hasSettler = tile.units.some(unit => unit.type === 'settler' && unit.owner === 0);
                if (!tile.isCity && !tile.building && hasSettler) {
                    buildCityBtn.disabled = false;
                }
                
                // Build building (only on empty tile that's not a city)
                if (!tile.building && !tile.isCity && tile.type !== 'water' && tile.type !== 'mountain') {
                    buildBtn.disabled = false;
                }
                
                // Train unit (only in cities)
                if (tile.isCity) {
                    trainUnitBtn.disabled = false;
                }
                
                // Move unit (if there are player units)
                if (tile.units.some(unit => unit.owner === 0 && !unit.moved)) {
                    moveUnitBtn.disabled = false;
                }
                
                // Attack (if there are player units and adjacent enemy units)
                if (tile.units.some(unit => unit.owner === 0 && !unit.attacked) && hasAdjacentEnemies(tile.x, tile.y)) {
                    attackBtn.disabled = false;
                }
            }
        }
        
        // Check if there are adjacent enemy units or cities
        function hasAdjacentEnemies(x, y) {
            const directions = [
                { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                { x: -1, y: 0 }, /* center */ { x: 1, y: 0 },
                { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }
            ];
            
            for (const dir of directions) {
                const newX = x + dir.x;
                const newY = y + dir.y;
                
                // Check if within bounds
                if (newX >= 0 && newX < 10 && newY >= 0 && newY < 10) {
                    const tile = gameState.tiles[newY][newX];
                    
                    // Check for enemy city
                    if (tile.isCity && tile.owner !== 0 && gameState.players[tile.owner].alive) {
                        return true;
                    }
                    
                    // Check for enemy units
                    if (tile.units.some(unit => unit.owner !== 0 && gameState.players[unit.owner].alive)) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        // Build a city
        function buildCity() {
            const tile = gameState.selectedTile;
            
            if (!tile) return;
            
            // Find settler unit
            const settlerIndex = tile.units.findIndex(unit => unit.type === 'settler' && unit.owner === 0);
            
            if (settlerIndex === -1) return;
            
            // Remove settler unit
            const settler = tile.units.splice(settlerIndex, 1)[0];
            
            // Update UI to remove unit
            updateUnitsUI(tile);
            
            // Build city
            tile.isCity = true;
            tile.owner = 0;
            
            // Add city icon
            const cityIcon = document.createElement('div');
            cityIcon.classList.add('tile-building');
            cityIcon.style.backgroundImage = `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><rect x="2" y="10" width="20" height="12" fill="%23607D8B"/><rect x="4" y="6" width="16" height="4" fill="%2378909C"/><rect x="7" y="2" width="10" height="4" fill="%23B0BEC5"/><rect x="5" y="14" width="3" height="3" fill="%23CFD8DC"/><rect x="10" y="14" width="3" height="3" fill="%23CFD8DC"/><rect x="15" y="14" width="3" height="3" fill="%23CFD8DC"/><rect x="5" y="19" width="13" height="1" fill="%23B0BEC5"/></svg>')`;
            tile.element.appendChild(cityIcon);
            
            // Ensure owner color is visible
            if (!tile.element.querySelector('.tile-owner')) {
                const ownerColor = document.createElement('div');
                ownerColor.classList.add('tile-owner');
                ownerColor.style.backgroundColor = gameState.players[0].color;
                tile.element.appendChild(ownerColor);
            }
            
            // Claim adjacent tiles
            claimAdjacentTiles(tile.x, tile.y, 0);
            
            // Update UI
            updateInfoPanel();
            updateActionButtons();
            
            // Show alert
            showAlert('City founded!');
            
            // Update stats
            gameState.stats.citiesBuilt++;
        }
        
        // Start building construction
        function showBuildingMenu() {
            const tile = gameState.selectedTile;
            
            if (!tile) return;
            
            // Position the menu
            const rect = tile.element.getBoundingClientRect();
            buildingMenu.style.left = `${rect.left}px`;
            buildingMenu.style.top = `${rect.bottom + 10}px`;
            
            // Show the menu
            buildingMenu.style.display = 'block';
            
            // Add click outside to close
            setTimeout(() => {
                document.addEventListener('click', hideBuildingMenuOnClickOutside);
            }, 0);
        }
        
        // Hide building menu
        function hideBuildingMenu() {
            buildingMenu.style.display = 'none';
            document.removeEventListener('click', hideBuildingMenuOnClickOutside);
        }
        
        // Hide building menu when clicking outside
        function hideBuildingMenuOnClickOutside(e) {
            if (!buildingMenu.contains(e.target) && e.target !== buildBtn) {
                hideBuildingMenu();
            }
        }
        
        // Build a building
        function buildBuilding(buildingType) {
            const tile = gameState.selectedTile;
            
            if (!tile) return;
            
            // Check if player has enough production
            let cost;
            let benefit;
            
            switch (buildingType) {
                case 'farm':
                    cost = 50;
                    benefit = '+2 Food';
                    break;
                case 'mine':
                    cost = 50;
                    benefit = '+2 Production';
                    break;
                case 'market':
                    cost = 75;
                    benefit = '+3 Gold';
                    break;
                case 'library':
                    cost = 75;
                    benefit = '+3 Science';
                    break;
                case 'barracks':
                    cost = 100;
                    benefit = 'Military';
                    break;
            }
            
            if (gameState.players[0].gold < cost) {
                showAlert(`Not enough gold! Need ${cost}🪙`);
                return;
            }
            
            // Deduct cost
            gameState.players[0].gold -= cost;
            
            // Set building
            tile.building = buildingType;
            
            // Add building icon
            const buildingIcon = document.createElement('div');
            buildingIcon.classList.add('tile-building');
            
            switch (buildingType) {
                case 'farm':
                    buildingIcon.style.backgroundImage = `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><rect x="2" y="8" width="20" height="14" fill="%23795548"/><rect x="4" y="12" width="16" height="10" fill="%238D6E63"/><rect x="8" y="2" width="8" height="6" fill="%23A1887F"/><rect x="10" y="2" width="4" height="10" fill="%23795548"/></svg>')`;
                    break;
                case 'mine':
                    buildingIcon.style.backgroundImage = `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M2,22 L22,22 L12,2 L2,22 Z" fill="%23757575"/><path d="M8,16 L16,16 L12,6 L8,16 Z" fill="%23424242"/></svg>')`;
                    break;
                case 'market':
                    buildingIcon.style.backgroundImage = `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><rect x="2" y="4" width="20" height="16" fill="%23FFC107"/><path d="M2,8 L22,8" stroke="%23795548" stroke-width="2"/><path d="M6,4 L6,20" stroke="%23795548" stroke-width="2"/><path d="M12,4 L12,20" stroke="%23795548" stroke-width="2"/><path d="M18,4 L18,20" stroke="%23795548" stroke-width="2"/></svg>')`;
                    break;
                case 'library':
                    buildingIcon.style.backgroundImage = `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><rect x="2" y="4" width="20" height="16" fill="%233F51B5"/><rect x="5" y="7" width="3" height="10" fill="%23C5CAE9"/><rect x="10" y="7" width="3" height="10" fill="%23C5CAE9"/><rect x="15" y="7" width="3" height="10" fill="%23C5CAE9"/></svg>')`;
                    break;
                case 'barracks':
                    buildingIcon.style.backgroundImage = `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><rect x="3" y="6" width="18" height="12" fill="%23795548"/><path d="M3,6 L12,2 L21,6" fill="%238D6E63"/><rect x="8" y="10" width="8" height="8" fill="%23A1887F"/></svg>')`;
                    break;
            }
            
            tile.element.appendChild(buildingIcon);
            
            // Update UI
            updateResourceDisplay();
            updateInfoPanel();
            updateActionButtons();
            
            // Show alert
            showAlert(`Built ${buildingType}! ${benefit}`);
        }
        
        // Show unit training menu
        function showUnitMenu() {
            const tile = gameState.selectedTile;
            
            if (!tile) return;
            
            // Position the menu
            const rect = tile.element.getBoundingClientRect();
            unitMenu.style.left = `${rect.left}px`;
            unitMenu.style.top = `${rect.bottom + 10}px`;
            
            // Show the menu
            unitMenu.style.display = 'block';
            
            // Add click outside to close
            setTimeout(() => {
                document.addEventListener('click', hideUnitMenuOnClickOutside);
            }, 0);
        }
        
        // Hide unit menu
        function hideUnitMenu() {
            unitMenu.style.display = 'none';
            document.removeEventListener('click', hideUnitMenuOnClickOutside);
        }
        
        // Hide unit menu when clicking outside
        function hideUnitMenuOnClickOutside(e) {
            if (!unitMenu.contains(e.target) && e.target !== trainUnitBtn) {
                hideUnitMenu();
            }
        }
        
        // Train a unit
        function trainUnit(unitType) {
            const tile = gameState.selectedTile;
            
            if (!tile) return;
            
            // Check if unit is unlocked
            if (unitType !== 'warrior' && unitType !== 'settler') {
                const technology = gameState.technologies.find(tech => 
                    tech.unlocks.includes(capitalizeFirstLetter(unitType)));
                if (technology && !technology.researched) {
                    showAlert(`You need to research ${technology.name} first!`);
                    return;
                }
            }
            
            // Check if player has enough production
            let cost;
            let stats;
            
            switch (unitType) {
                case 'warrior':
                    cost = 50;
                    stats = 'A:2 D:2';
                    break;
                case 'archer':
                    cost = 60;
                    stats = 'A:3 D:1';
                    break;
                case 'swordsman':
                    cost = 80;
                    stats = 'A:4 D:2';
                    break;
                case 'knight':
                    cost = 100;
                    stats = 'A:5 D:3';
                    break;
                case 'settler':
                    cost = 100;
                    stats = 'Founds cities';
                    break;
            }
            
            if (gameState.players[0].gold < cost) {
                showAlert(`Not enough gold! Need ${cost}🪙`);
                return;
            }
            
            // Deduct cost
            gameState.players[0].gold -= cost;
            
            // Create unit
            const unit = {
                type: unitType,
                owner: 0,
                attack: getAttackValue(unitType),
                defense: getDefenseValue(unitType),
                moved: true,
                attacked: true
            };
            
            // Add unit to tile
            tile.units.push(unit);
            
            // Update units UI
            updateUnitsUI(tile);
            
            // Update UI
            updateResourceDisplay();
            updateInfoPanel();
            updateActionButtons();
            
            // Show alert
            showAlert(`Trained ${unitType}! ${stats}`);
            
            // Update stats
            gameState.stats.unitsTrained++;
        }
        
        // Get attack value for unit type
        function getAttackValue(unitType) {
            switch (unitType) {
                case 'warrior': return 2;
                case 'archer': return 3;
                case 'swordsman': return 4;
                case 'knight': return 5;
                default: return 1;
            }
        }
        
        // Get defense value for unit type
        function getDefenseValue(unitType) {
            switch (unitType) {
                case 'warrior': return 2;
                case 'archer': return 1;
                case 'swordsman': return 2;
                case 'knight': return 3;
                default: return 1;
            }
        }
        
        // Add this function to show unit icons on tiles
        function updateUnitsUI(tile) {
            // Remove existing unit indicators and icons
            const existingUnits = tile.element.querySelector('.tile-units');
            if (existingUnits) {
                tile.element.removeChild(existingUnits);
            }
            
            const existingUnitIcon = tile.element.querySelector('.unit-icon');
            if (existingUnitIcon) {
                tile.element.removeChild(existingUnitIcon);
            }
            
            // Add unit indicator if there are units
            if (tile.units.length > 0) {
                // Create counter for multiple units
                const unitsElement = document.createElement('div');
                unitsElement.classList.add('tile-units');
                unitsElement.textContent = tile.units.length;
                tile.element.appendChild(unitsElement);
                
                // Add visual icon for the strongest unit
                let strongestUnit = tile.units[0];
                for (const unit of tile.units) {
                    if (unit.attack > strongestUnit.attack) {
                        strongestUnit = unit;
                    }
                }
                
                const unitIcon = document.createElement('div');
                unitIcon.classList.add('unit-icon');
                unitIcon.style.position = 'absolute';
                unitIcon.style.bottom = '5px';
                unitIcon.style.left = '5px';
                unitIcon.style.width = '70%';
                unitIcon.style.height = '70%';
                unitIcon.style.backgroundSize = 'contain';
                unitIcon.style.backgroundPosition = 'center';
                unitIcon.style.backgroundRepeat = 'no-repeat';
                unitIcon.style.zIndex = '1';
                
                // Set unit icon based on type
                switch (strongestUnit.type) {
                    case 'warrior':
                        unitIcon.style.backgroundImage = getUnitImage('warrior', strongestUnit.owner);
                        break;
                    case 'archer':
                        unitIcon.style.backgroundImage = getUnitImage('archer', strongestUnit.owner);
                        break;
                    case 'swordsman':
                        unitIcon.style.backgroundImage = getUnitImage('swordsman', strongestUnit.owner);
                        break;
                    case 'knight':
                        unitIcon.style.backgroundImage = getUnitImage('knight', strongestUnit.owner);
                        break;
                    case 'settler':
                        unitIcon.style.backgroundImage = getUnitImage('settler', strongestUnit.owner);
                        break;
                }
                
                tile.element.appendChild(unitIcon);
            }
        }
        // Start moving a unit
        function startMoveUnit() {
            const fromTile = gameState.selectedTile;
            
            if (!fromTile || !fromTile.units.some(unit => unit.owner === 0 && !unit.moved)) {
                return;
            }
            
            // Show alert for instructions
            showAlert('Select a destination tile');
            
            // Highlight valid move tiles
            highlightValidMoveTiles(fromTile);
            
            // Store the move state
            gameState.moveState = {
                fromTile,
                movingUnit: fromTile.units.find(unit => unit.owner === 0 && !unit.moved)
            };
            
            // Add click handler for selecting destination
            document.addEventListener('click', selectMoveDestination);
        }
        
        // Highlight valid tiles for movement
        function highlightValidMoveTiles(fromTile) {
            const directions = [
                { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                { x: -1, y: 0 }, /* center */ { x: 1, y: 0 },
                { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }
            ];
            
            for (const dir of directions) {
                const newX = fromTile.x + dir.x;
                const newY = fromTile.y + dir.y;
                
                // Skip if outside bounds
                if (newX < 0 || newX >= 10 || newY < 0 || newY >= 10) continue;
                
                const targetTile = gameState.tiles[newY][newX];
                
                // Skip water and mountain tiles
                if (targetTile.type === 'water' || targetTile.type === 'mountain') continue;
                
                // Skip enemy cities
                if (targetTile.isCity && targetTile.owner !== 0) continue;
                
                // Skip tiles with enemy units
                if (targetTile.units.some(unit => unit.owner !== 0)) continue;
                
                // Highlight the tile
                targetTile.element.style.boxShadow = 'inset 0 0 10px rgba(255, 255, 0, 0.8)';
            }
        }
        
        // Select destination tile for movement
        function selectMoveDestination(e) {
            // Find the clicked tile
            const tileElement = e.target.closest('.tile');
            if (!tileElement) return;
            
            // Find the tile data
            let targetTile = null;
            for (let y = 0; y < 10; y++) {
                for (let x = 0; x < 10; x++) {
                    if (gameState.tiles[y][x].element === tileElement) {
                        targetTile = gameState.tiles[y][x];
                        break;
                    }
                }
                if (targetTile) break;
            }
            
            // If no tile found or not a valid move, cancel
            if (!targetTile || targetTile === gameState.moveState.fromTile) {
                cancelMove();
                return;
            }
            
            // Check if it's a valid move
            const isValid = isValidMove(gameState.moveState.fromTile, targetTile);
            
            if (isValid) {
                // Move the unit
                moveUnit(gameState.moveState.fromTile, targetTile, gameState.moveState.movingUnit);
            }
            
            // Clean up
            cancelMove();
        }
        
        // Check if move is valid
        function isValidMove(fromTile, toTile) {
            // Check if tiles are adjacent
            const dx = Math.abs(fromTile.x - toTile.x);
            const dy = Math.abs(fromTile.y - toTile.y);
            
            if (dx > 1 || dy > 1) return false;
            
            // Check if destination is passable
            if (toTile.type === 'water' || toTile.type === 'mountain') return false;
            
            // Check if destination has enemy units
            if (toTile.units.some(unit => unit.owner !== 0)) return false;
            
            // Check if destination is an enemy city
            if (toTile.isCity && toTile.owner !== 0) return false;
            
            return true;
        }
        
// Move a unit from one tile to another
function moveUnit(fromTile, toTile, unit) {
    // Remove unit from source tile
    const unitIndex = fromTile.units.findIndex(u => u === unit);
    if (unitIndex === -1) return;
    
    fromTile.units.splice(unitIndex, 1);
    
    // Mark unit as moved
    unit.moved = true;
    
    // Add unit to target tile
    toTile.units.push(unit);
    
    // Update UI
    updateUnitsUI(fromTile);
    updateUnitsUI(toTile);
    
    // Select the new tile
    selectTile(toTile.x, toTile.y);
    
    // Show alert
    showAlert(`Unit moved!`);
}


        
        // Cancel move mode
        function cancelMove() {
            // Remove event listener
            document.removeEventListener('click', selectMoveDestination);
            
            // Clear highlights
            for (let y = 0; y < 10; y++) {
                for (let x = 0; x < 10; x++) {
                    gameState.tiles[y][x].element.style.boxShadow = '';
                }
            }
            
            // Clear move state
            gameState.moveState = null;
        }
        
        // Start attack
        function startAttack() {
            const fromTile = gameState.selectedTile;
            
            if (!fromTile || !fromTile.units.some(unit => unit.owner === 0 && !unit.attacked)) {
                return;
            }
            
            // Show alert for instructions
            showAlert('Select an enemy tile to attack');
            
            // Highlight valid attack targets
            highlightValidAttackTiles(fromTile);
            
            // Store the attack state
            gameState.attackState = {
                fromTile,
                attackingUnit: fromTile.units.find(unit => unit.owner === 0 && !unit.attacked)
            };
            
            // Add click handler for selecting target
            document.addEventListener('click', selectAttackTarget);
        }

        // Get defense bonus based on terrain
        function getDefenseBonus(tileType) {
            switch(tileType) {
                case 'mountain': return 1.5;
                case 'forest': return 1.3;
                case 'desert': return 0.8;
                case 'water': return 0.5;
                default: return 1.0;
            }
        }
        
        // Highlight valid tiles for attack
        function highlightValidAttackTiles(fromTile) {
            const directions = [
                { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                { x: -1, y: 0 }, /* center */ { x: 1, y: 0 },
                { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }
            ];
            
            for (const dir of directions) {
                const newX = fromTile.x + dir.x;
                const newY = fromTile.y + dir.y;
                
                // Skip if outside bounds
                if (newX < 0 || newX >= 10 || newY < 0 || newY >= 10) continue;
                
                const targetTile = gameState.tiles[newY][newX];
                
                // Check for enemy presence
                const hasEnemy = (targetTile.isCity && targetTile.owner !== 0 && gameState.players[targetTile.owner].alive) ||
                                 (targetTile.units.some(unit => unit.owner !== 0 && gameState.players[unit.owner].alive));
                
                if (hasEnemy) {
                    // Highlight the tile
                    targetTile.element.style.boxShadow = 'inset 0 0 10px rgba(255, 0, 0, 0.8)';
                }
            }
        }
        
        // Select attack target
        function selectAttackTarget(e) {
            // Find the clicked tile
            const tileElement = e.target.closest('.tile');
            if (!tileElement) return;
            
            // Find the tile data
            let targetTile = null;
            for (let y = 0; y < 10; y++) {
                for (let x = 0; x < 10; x++) {
                    if (gameState.tiles[y][x].element === tileElement) {
                        targetTile = gameState.tiles[y][x];
                        break;
                    }
                }
                if (targetTile) break;
            }
            
            // If no tile found or not a valid target, cancel
            if (!targetTile || targetTile === gameState.attackState.fromTile) {
                cancelAttack();
                return;
            }
            
            // Check if it's a valid attack
            const isValid = isValidAttack(gameState.attackState.fromTile, targetTile);
            
            if (isValid) {
                // Perform the attack
                performAttack(gameState.attackState.fromTile, targetTile, gameState.attackState.attackingUnit);
            }
            
            // Clean up
            cancelAttack();
        }
        
        // Check if attack is valid
        function isValidAttack(fromTile, toTile) {
            // Check if tiles are adjacent
            const dx = Math.abs(fromTile.x - toTile.x);
            const dy = Math.abs(fromTile.y - toTile.y);
            
            if (dx > 1 || dy > 1) return false;
            
            // Check for enemy presence
            return (toTile.isCity && toTile.owner !== 0 && gameState.players[toTile.owner].alive) ||
                   toTile.units.some(unit => unit.owner !== 0 && gameState.players[unit.owner].alive);
        }
        
        // Perform an attack
        // Enhanced combat system
        function performAttack(fromTile, toTile, attackingUnit) {
            // Mark unit as attacked
            attackingUnit.attacked = true;
            
            // Calculate attack strength with terrain bonuses
            let attackStrength = attackingUnit.attack;
            if (fromTile.type === 'mountain') attackStrength *= 1.2;
            if (fromTile.type === 'forest') attackStrength *= 1.1;
            
            // Calculate defense strength with terrain bonuses
            let defenseStrength = 0;
            let defendingUnit = null;
            
            if (toTile.units.length > 0) {
                // Find strongest defender
                for (const unit of toTile.units) {
                    if (unit.owner !== attackingUnit.owner) {
                        const defBonus = getDefenseBonus(toTile.type);
                        const unitDefense = unit.defense * defBonus;
                        if (unitDefense > defenseStrength) {
                            defenseStrength = unitDefense;
                            defendingUnit = unit;
                        }
                    }
                }
            } else if (toTile.isCity) {
                // Cities have base defense that scales with game progress
                const cityOwner = gameState.players[toTile.owner];
                defenseStrength = 3 + Math.floor(gameState.turn / 10);
                
                // Cities with barracks are stronger
                for (let y = 0; y < 10; y++) {
                    for (let x = 0; x < 10; x++) {
                        const tile = gameState.tiles[y][x];
                        if (tile.owner === toTile.owner && tile.building === 'barracks') {
                            defenseStrength += 2;
                            break;
                        }
                    }
                }
            }
            
            // Combat algorithm with randomness and feedback
            const attackRoll = Math.random() * 0.5 + 0.75; // 0.75 to 1.25
            const defenseRoll = Math.random() * 0.5 + 0.75; // 0.75 to 1.25
            
            const attackTotal = attackStrength * attackRoll;
            const defenseTotal = defenseStrength * defenseRoll;
            
            // Create combat log
            let message = `${attackingUnit.type} (${attackTotal.toFixed(1)}) attacking `;
            message += defendingUnit ? `${defendingUnit.type} (${defenseTotal.toFixed(1)})` : `city (${defenseTotal.toFixed(1)})`;
            
            if (attackTotal > defenseTotal) {
                // Attacker wins
                if (defendingUnit) {
                    // Remove defender unit
                    const unitIndex = toTile.units.indexOf(defendingUnit);
                    toTile.units.splice(unitIndex, 1);
                    updateUnitsUI(toTile);
                    
                    message = `Victory! Enemy ${defendingUnit.type} defeated!`;
                    
                    // 20% chance to gain experience for unit
                    if (Math.random() < 0.2) {
                        attackingUnit.attack += 0.5;
                        message += " Your unit gained combat experience!";
                    }
                } else if (toTile.isCity) {
                    // Capture city
                    const formerOwner = toTile.owner;
                    toTile.owner = attackingUnit.owner;
                    
                    // Update city appearance
                    for (const child of [...toTile.element.children]) {
                        if (child.classList.contains('tile-owner')) {
                            child.style.backgroundColor = gameState.players[attackingUnit.owner].color;
                        }
                    }
                    
                    message = `Victory! City captured from ${gameState.players[formerOwner].name}!`;
                    
                    // Check if player defeated
                    checkPlayerDefeated(formerOwner);
                }
            } else {
                // Defender wins
                message = 'Attack failed! Enemy defenses held.';
                
                // 10% chance attacker is destroyed on a strong defense
                if (defenseTotal > attackTotal * 1.5 && Math.random() < 0.1) {
                    const unitIndex = fromTile.units.indexOf(attackingUnit);
                    fromTile.units.splice(unitIndex, 1);
                    updateUnitsUI(fromTile);
                    message += " Your unit was destroyed in the failed attack!";
                }
            }
            
            // Show alert
            showAlert(message);
            
            // Update UI
            updateInfoPanel();
            updateActionButtons();
        }
        
        // Cancel attack mode
        function cancelAttack() {
            // Remove event listener
            document.removeEventListener('click', selectAttackTarget);
            
            // Clear highlights
            for (let y = 0; y < 10; y++) {
                for (let x = 0; x < 10; x++) {
                    gameState.tiles[y][x].element.style.boxShadow = '';
                }
            }
            
            // Clear attack state
            gameState.attackState = null;
        }
        
        // Check if a player is defeated
        function checkPlayerDefeated(playerId) {
            // Skip player 0 (human player)
            if (playerId === 0) return;
            
            // Check if player has any cities left
            let hasCities = false;
            
            for (let y = 0; y < 10; y++) {
                for (let x = 0; x < 10; x++) {
                    const tile = gameState.tiles[y][x];
                    if (tile.isCity && tile.owner === playerId) {
                        hasCities = true;
                        break;
                    }
                }
                if (hasCities) break;
            }
            
            if (!hasCities) {
                // Player is defeated
                gameState.players[playerId].alive = false;
                
                // Update UI to show defeated
                updateAIStatus();
                
                // Show alert
                showAlert(`${gameState.players[playerId].name} has been defeated!`);
                
                // Update stats
                gameState.stats.enemiesDefeated++;
                
                // Check for victory
                checkVictory();
            }
        }
        
        // Check if player has won
        function checkVictory() {
            // Check if all AI players are defeated
            const allDefeated = gameState.players.slice(1).every(player => !player.alive);
            
            if (allDefeated) {
                // Victory!
                showVictoryScreen();
            }
        }
        
        // Show victory screen
        function showVictoryScreen() {
            // Update stats
            finalTurns.textContent = gameState.turn;
            finalCities.textContent = gameState.stats.citiesBuilt;
            finalUnits.textContent = gameState.stats.unitsTrained;
            finalEnemies.textContent = gameState.stats.enemiesDefeated;
            
            // Display victory screen
            victoryScreen.style.display = 'flex';
        }
        
        // Show technology tree
        function showTechTree() {
            // Update tech tree UI
            updateTechTree();
            
            // Show panel
            techTreePanel.style.display = 'block';
        }
        
        // Hide technology tree
        function hideTechTree() {
            techTreePanel.style.display = 'none';
        }
        
        // Update technology tree
        function updateTechTree() {
            techTreeContainer.innerHTML = '';
            
            for (const tech of gameState.technologies) {
                const techElement = document.createElement('div');
                techElement.classList.add('tech-item');
                
                // Add appropriate classes
                if (tech.researched) {
                    techElement.classList.add('researched');
                } else if (isTechAvailable(tech)) {
                    techElement.classList.add('available');
                }
                
                // Add tech info
                techElement.innerHTML = `
                    <h3>${tech.name}</h3>
                    <p>${tech.description}</p>
                    <p>Cost: ${tech.cost} 🧪</p>
                `;
                
                // Add click event for available techs
                if (!tech.researched && isTechAvailable(tech)) {
                    techElement.addEventListener('click', () => {
                        startResearch(tech.id);
                        hideTechTree();
                    });
                }
                
                techTreeContainer.appendChild(techElement);
            }
        }
        
        // Check if a technology is available for research
        function isTechAvailable(tech) {
            // Check if all dependencies are researched
            return tech.dependencies.every(depId => {
                const dependency = gameState.technologies.find(t => t.id === depId);
                return dependency && dependency.researched;
            });
        }
        
        // Start researching a technology
        function startResearch(techId) {
            const tech = gameState.technologies.find(t => t.id === techId);
            
            if (!tech || tech.researched || !isTechAvailable(tech)) {
                return;
            }
            
            gameState.currentResearch = tech;
            gameState.sciencePoints = 0;
            
            showAlert(`Now researching: ${tech.name}`);
        }
        
        // Complete research
        function completeResearch(tech) {
            tech.researched = true;
            gameState.currentResearch = null;
            gameState.sciencePoints = 0;
            
            showAlert(`Research complete: ${tech.name}`);
        }
        
        // End the current turn
        function endTurn() {
            // Process resources from buildings
            collectResources();
            
            // Process research
            processResearch();
            
            // Reset unit movement and attack
            resetUnits();
            
            // Process AI turns
            for (let i = 1; i < gameState.players.length; i++) {
                if (gameState.players[i].alive) {
                    processAITurn(i);
                }
            }
            
            // Increment turn counter
            gameState.turn++;
            turnCounter.textContent = gameState.turn;
            
            // Update UI
            updateResourceDisplay();
            updateActionButtons();
            
            // Make sure we're not still in move or attack mode
            if (gameState.moveState) cancelMove();
            if (gameState.attackState) cancelAttack();
        }
        
        // Collect resources from buildings
        function collectResources() {
            let goldIncome = 5; // Base income
            let foodIncome = 0;
            let productionIncome = 0;
            let scienceIncome = 0;
            
            // Count cities
            let cityCount = 0;
            
            // Process each tile
            for (let y = 0; y < 10; y++) {
                for (let x = 0; x < 10; x++) {
                    const tile = gameState.tiles[y][x];
                    
                    if (tile.owner === 0) {
                        // Process cities
                        if (tile.isCity) {
                            goldIncome += 2;
                            foodIncome += 1;
                            productionIncome += 1;
                            scienceIncome += 1;
                            cityCount++;
                        }
                        
                        // Process buildings
                        if (tile.building) {
                            switch (tile.building) {
                                case 'farm':
                                    foodIncome += 2;
                                    break;
                                case 'mine':
                                    productionIncome += 2;
                                    break;
                                case 'market':
                                    goldIncome += 3;
                                    break;
                                case 'library':
                                    scienceIncome += 3;
                                    break;
                                // Barracks don't provide resources
                            }
                        }
                    }
                }
            }
            
            // Apply income
            gameState.players[0].gold += goldIncome;
            gameState.players[0].food = foodIncome;
            gameState.players[0].production = productionIncome;
            gameState.players[0].science = scienceIncome;
            
            // Update display
            updateResourceDisplay();
        }
        
        // Process research progress
        function processResearch() {
            if (!gameState.currentResearch) return;
            
            const sciencePoints = gameState.players[0].science;
            gameState.sciencePoints += sciencePoints;
            
            // Check if research is complete
            if (gameState.sciencePoints >= gameState.currentResearch.cost) {
                completeResearch(gameState.currentResearch);
            }
        }
        
        // Reset units for new turn
        function resetUnits() {
            for (let y = 0; y < 10; y++) {
                for (let x = 0; x < 10; x++) {
                    const tile = gameState.tiles[y][x];
                    
                    for (const unit of tile.units) {
                        unit.moved = false;
                        unit.attacked = false;
                    }
                }
            }
        }
        
        // Process AI turn
        function processAITurn(playerId) {
            const player = gameState.players[playerId];
            
            // Collect AI resources (simplified)
            player.gold += 10;
            
            // Find AI cities
            const aiCities = [];
            for (let y = 0; y < 10; y++) {
                for (let x = 0; x < 10; x++) {
                    const tile = gameState.tiles[y][x];
                    if (tile.isCity && tile.owner === playerId) {
                        aiCities.push(tile);
                    }
                }
            }
            
            // If AI has no cities, they're already defeated
            if (aiCities.length === 0) {
                player.alive = false;
                return;
            }
            
            // Find all AI units
            const aiUnits = [];
            for (let y = 0; y < 10; y++) {
                for (let x = 0; x < 10; x++) {
                    const tile = gameState.tiles[y][x];
                    for (const unit of tile.units) {
                        if (unit.owner === playerId) {
                            aiUnits.push({ unit, tile });
                        }
                    }
                }
            }
            
            // Train units if gold available
            if (player.gold >= 50 && aiCities.length > 0) {
                const randomCity = aiCities[Math.floor(Math.random() * aiCities.length)];
                
                // 50% chance to train a unit
                if (Math.random() < 0.5) {
                    // Determine unit type based on player's gold
                    let unitType = 'warrior';
                    let unitCost = 50;
                    
                    if (player.gold >= 100) {
                        unitType = 'knight';
                        unitCost = 100;
                    } else if (player.gold >= 80) {
                        unitType = 'swordsman';
                        unitCost = 80;
                    } else if (player.gold >= 60) {
                        unitType = 'archer';
                        unitCost = 60;
                    }
                    
                    // Create unit
                    const unit = {
                        type: unitType,
                        owner: playerId,
                        attack: getAttackValue(unitType),
                        defense: getDefenseValue(unitType),
                        moved: true,
                        attacked: true
                    };
                    
                    // Add unit to city
                    randomCity.units.push(unit);
                    player.gold -= unitCost;
                    
                    // Update UI
                    updateUnitsUI(randomCity);
                }
            }
            
            // Move units towards player cities or units
            for (const aiUnit of aiUnits) {
                const { unit, tile } = aiUnit;
                
                // Find player cities and units
                const targets = [];
                for (let y = 0; y < 10; y++) {
                    for (let x = 0; x < 10; x++) {
                        const targetTile = gameState.tiles[y][x];
                        
                        // Check for player cities
                        if (targetTile.isCity && targetTile.owner === 0) {
                            targets.push(targetTile);
                        }
                        
                        // Check for player units
                        if (targetTile.units.some(u => u.owner === 0)) {
                            targets.push(targetTile);
                        }
                    }
                }
                
                // If no targets, AI can't do anything
                if (targets.length === 0) continue;
                
                // Find closest target
                let closestTarget = null;
                let shortestDistance = Infinity;
                
                for (const target of targets) {
                    const distance = Math.abs(tile.x - target.x) + Math.abs(tile.y - target.y);
                    if (distance < shortestDistance) {
                        shortestDistance = distance;
                        closestTarget = target;
                    }
                }
                
                // If already adjacent to target, attack
                if (shortestDistance === 1) {
                    // Perform attack (simplified for AI)
                    if (closestTarget.isCity && closestTarget.owner === 0) {
                        // Attack city (simplified, 30% chance of success)
                        if (Math.random() < 0.3) {
                            closestTarget.owner = playerId;
                            
                            // Update city appearance
                            for (const child of [...closestTarget.element.children]) {
                                if (child.classList.contains('tile-owner')) {
                                    child.style.backgroundColor = player.color;
                                }
                            }
                            
                            showAlert(`${player.name} has captured your city!`);
                        }
                    } else if (closestTarget.units.some(u => u.owner === 0)) {
                        // Attack unit (simplified, 30% chance of success)
                        if (Math.random() < 0.3) {
                            const playerUnitIndex = closestTarget.units.findIndex(u => u.owner === 0);
                            if (playerUnitIndex !== -1) {
                                closestTarget.units.splice(playerUnitIndex, 1);
                                updateUnitsUI(closestTarget);
                                showAlert(`${player.name} has defeated your unit!`);
                            }
                        }
                    }
                } else {
                    // Move towards target (basic AI)
                    // Find direction to move
                    const dx = closestTarget.x - tile.x;
                    const dy = closestTarget.y - tile.y;
                    
                    // Determine best move direction
                    let moveX = 0;
                    let moveY = 0;
                    
                    if (Math.abs(dx) > Math.abs(dy)) {
                        // Move horizontally
                        moveX = dx > 0 ? 1 : -1;
                    } else {
                        // Move vertically
                        moveY = dy > 0 ? 1 : -1;
                    }
                    
                    // Check target tile
                    const newX = tile.x + moveX;
                    const newY = tile.y + moveY;
                    
                    // Skip if outside bounds
                    if (newX < 0 || newX >= 10 || newY < 0 || newY >= 10) continue;
                    
                    const targetTile = gameState.tiles[newY][newX];
                    
                    // Skip water and mountain tiles
                    if (targetTile.type === 'water' || targetTile.type === 'mountain') continue;
                    
                    // Skip if tile has units
                    if (targetTile.units.length > 0) continue;
                    
                    // Skip enemy cities
                    if (targetTile.isCity && targetTile.owner !== playerId) continue;
                    
                    // Move unit
                    tile.units = tile.units.filter(u => u !== unit);
                    targetTile.units.push(unit);
                    
                    // Update UI
                    updateUnitsUI(tile);
                    updateUnitsUI(targetTile);
                }
            }
        }

        // Show diplomacy panel (continued)
function showDiplomacyPanel() {
    const panel = document.getElementById('diplomacy-panel');
    const aiList = document.getElementById('diplomacy-ai-list');
    
    // Clear previous content
    aiList.innerHTML = '';
    
    // Add each AI player
    for (let i = 1; i < gameState.players.length; i++) {
        if (!gameState.players[i].alive) continue;
        
        const aiPlayer = gameState.players[i];
        const relationValue = gameState.diplomacy.relations[0][i];
        const treaties = gameState.diplomacy.treaties[0][i];
        
        const aiContainer = document.createElement('div');
        aiContainer.className = 'ai-diplomatic-status';
        
        // Add AI name and color
        const aiHeader = document.createElement('div');
        aiHeader.style.display = 'flex';
        aiHeader.style.alignItems = 'center';
        aiHeader.style.marginBottom = '0.5rem';
        
        const aiColor = document.createElement('div');
        aiColor.style.width = '20px';
        aiColor.style.height = '20px';
        aiColor.style.backgroundColor = aiPlayer.color;
        aiColor.style.borderRadius = '50%';
        aiColor.style.marginRight = '0.5rem';
        
        const aiName = document.createElement('h3');
        aiName.textContent = aiPlayer.name;
        
        aiHeader.appendChild(aiColor);
        aiHeader.appendChild(aiName);
        aiContainer.appendChild(aiHeader);
        
        // Add relation meter
        const relationLabel = document.createElement('div');
        relationLabel.textContent = getRelationshipStatus(relationValue);
        aiContainer.appendChild(relationLabel);
        
        const relationMeter = document.createElement('div');
        relationMeter.className = 'relation-meter';
        
        const relationBar = document.createElement('div');
        relationBar.className = 'relation-value';
        relationBar.style.width = `${relationValue}%`;
        
        relationMeter.appendChild(relationBar);
        aiContainer.appendChild(relationMeter);
        
        // Add treaty status
        const treatyStatus = document.createElement('div');
        treatyStatus.className = 'treaty-status';
        
        if (treaties.peace) {
            const peaceBadge = document.createElement('span');
            peaceBadge.className = 'treaty-badge';
            peaceBadge.textContent = 'Peace Treaty';
            peaceBadge.style.backgroundColor = '#2ecc71';
            treatyStatus.appendChild(peaceBadge);
        }
        
        if (treaties.alliance) {
            const allianceBadge = document.createElement('span');
            allianceBadge.className = 'treaty-badge';
            allianceBadge.textContent = 'Alliance';
            allianceBadge.style.backgroundColor = '#3498db';
            treatyStatus.appendChild(allianceBadge);
        }
        
        if (treaties.tradeAgreement) {
            const tradeBadge = document.createElement('span');
            tradeBadge.className = 'treaty-badge';
            tradeBadge.textContent = 'Trade Agreement';
            tradeBadge.style.backgroundColor = '#f1c40f';
            treatyStatus.appendChild(tradeBadge);
        }
        
        aiContainer.appendChild(treatyStatus);
        
        // Add diplomatic actions
        const actionsContainer = document.createElement('div');
        actionsContainer.className = 'diplomatic-actions';
        
        // Declare war/Make peace button
        const warPeaceBtn = document.createElement('button');
        warPeaceBtn.className = 'diplomatic-action';
        
        if (treaties.peace || treaties.alliance) {
            warPeaceBtn.textContent = 'Declare War';
            warPeaceBtn.style.backgroundColor = '#e74c3c';
            warPeaceBtn.addEventListener('click', () => {
                declareWar(i);
                showDiplomacyPanel(); // Refresh panel
            });
        } else {
            warPeaceBtn.textContent = 'Offer Peace';
            warPeaceBtn.addEventListener('click', () => {
                offerPeace(i);
                showDiplomacyPanel(); // Refresh panel
            });
        }
        
        actionsContainer.appendChild(warPeaceBtn);
        
        // Alliance button
        if (treaties.peace && !treaties.alliance) {
            const allianceBtn = document.createElement('button');
            allianceBtn.className = 'diplomatic-action';
            allianceBtn.textContent = 'Propose Alliance';
            allianceBtn.addEventListener('click', () => {
                proposeAlliance(i);
                showDiplomacyPanel(); // Refresh panel
            });
            actionsContainer.appendChild(allianceBtn);
        }
        
        // Trade agreement button
        if (treaties.peace && !treaties.tradeAgreement) {
            const tradeBtn = document.createElement('button');
            tradeBtn.className = 'diplomatic-action';
            tradeBtn.textContent = 'Propose Trade';
            tradeBtn.addEventListener('click', () => {
                proposeTrade(i);
                showDiplomacyPanel(); // Refresh panel
            });
            actionsContainer.appendChild(tradeBtn);
        }
        
        aiContainer.appendChild(actionsContainer);
        aiList.appendChild(aiContainer);
    }
    
    // Show the panel
    panel.style.display = 'block';
}

// Get relationship status text based on relation value
function getRelationshipStatus(value) {
    if (value < 20) return 'Hostile';
    if (value < 40) return 'Unfriendly';
    if (value < 60) return 'Neutral';
    if (value < 80) return 'Friendly';
    return 'Allied';
}

// Diplomatic actions
function declareWar(playerId) {
    // Cancel all treaties
    gameState.diplomacy.treaties[0][playerId] = {
        peace: false,
        alliance: false,
        tradeAgreement: false,
        expires: 0
    };
    
    // Also cancel from AI side
    gameState.diplomacy.treaties[playerId][0] = {
        peace: false,
        alliance: false,
        tradeAgreement: false,
        expires: 0
    };
    
    // Decrease relations
    gameState.diplomacy.relations[0][playerId] = Math.max(0, gameState.diplomacy.relations[0][playerId] - 30);
    gameState.diplomacy.relations[playerId][0] = Math.max(0, gameState.diplomacy.relations[playerId][0] - 30);
    
    // Record message
    addDiplomaticMessage(`You declared war on ${gameState.players[playerId].name}!`);
    
    // Update AI behavior
    updateAIBehavior();
}

function offerPeace(playerId) {
    // Calculate acceptance chance based on relations
    const relationValue = gameState.diplomacy.relations[playerId][0];
    const acceptChance = relationValue / 100;
    
    if (Math.random() < acceptChance) {
        // AI accepts
        gameState.diplomacy.treaties[0][playerId].peace = true;
        gameState.diplomacy.treaties[playerId][0].peace = true;
        
        // Set expiration after 10 turns
        const expiration = gameState.turn + 10;
        gameState.diplomacy.treaties[0][playerId].expires = expiration;
        gameState.diplomacy.treaties[playerId][0].expires = expiration;
        
        // Improve relations
        gameState.diplomacy.relations[0][playerId] = Math.min(100, gameState.diplomacy.relations[0][playerId] + 10);
        gameState.diplomacy.relations[playerId][0] = Math.min(100, gameState.diplomacy.relations[playerId][0] + 10);
        
        addDiplomaticMessage(`${gameState.players[playerId].name} has accepted your peace treaty!`);
    } else {
        // AI rejects
        addDiplomaticMessage(`${gameState.players[playerId].name} has rejected your peace treaty.`);
    }
    
    updateAIBehavior();
}

function proposeAlliance(playerId) {
    // Calculate acceptance chance based on relations
    const relationValue = gameState.diplomacy.relations[playerId][0];
    const acceptChance = (relationValue - 50) / 50; // Only likely if relations are good
    
    if (Math.random() < acceptChance) {
        // AI accepts
        gameState.diplomacy.treaties[0][playerId].alliance = true;
        gameState.diplomacy.treaties[playerId][0].alliance = true;
        
        // Set expiration after 15 turns
        const expiration = gameState.turn + 15;
        gameState.diplomacy.treaties[0][playerId].expires = expiration;
        gameState.diplomacy.treaties[playerId][0].expires = expiration;
        
        // Significantly improve relations
        gameState.diplomacy.relations[0][playerId] = Math.min(100, gameState.diplomacy.relations[0][playerId] + 20);
        gameState.diplomacy.relations[playerId][0] = Math.min(100, gameState.diplomacy.relations[playerId][0] + 20);
        
        addDiplomaticMessage(`${gameState.players[playerId].name} has accepted your alliance proposal!`);
    } else {
        // AI rejects
        addDiplomaticMessage(`${gameState.players[playerId].name} has rejected your alliance proposal.`);
    }
    
    updateAIBehavior();
}

function proposeTrade(playerId) {
    // Calculate acceptance chance
    const relationValue = gameState.diplomacy.relations[playerId][0];
    const acceptChance = (relationValue - 30) / 70; // More likely to accept than alliance
    
    if (Math.random() < acceptChance) {
        // AI accepts
        gameState.diplomacy.treaties[0][playerId].tradeAgreement = true;
        gameState.diplomacy.treaties[playerId][0].tradeAgreement = true;
        
        // Set expiration after 10 turns
        const expiration = gameState.turn + 10;
        gameState.diplomacy.treaties[0][playerId].expires = expiration;
        gameState.diplomacy.treaties[playerId][0].expires = expiration;
        
        // Improve relations
        gameState.diplomacy.relations[0][playerId] = Math.min(100, gameState.diplomacy.relations[0][playerId] + 15);
        gameState.diplomacy.relations[playerId][0] = Math.min(100, gameState.diplomacy.relations[playerId][0] + 15);
        
        addDiplomaticMessage(`${gameState.players[playerId].name} has accepted your trade agreement!`);
    } else {
        // AI rejects
        addDiplomaticMessage(`${gameState.players[playerId].name} has rejected your trade agreement.`);
    }
    
    updateAIBehavior();
}

// Add diplomatic message
function addDiplomaticMessage(message) {
    gameState.diplomacy.messages.push({
        turn: gameState.turn,
        message: message
    });
    
    // Show message to player
    showAlert(message);
}

// Process diplomacy at end of turn
function processDiplomacy() {
    // Check treaties for expiration
    for (let i = 0; i < gameState.players.length; i++) {
        for (let j = 0; j < gameState.players.length; j++) {
            if (i !== j) {
                const treaties = gameState.diplomacy.treaties[i][j];
                
                // If treaties are about to expire, notify
                if (treaties.expires === gameState.turn + 1) {
                    if (i === 0 || j === 0) { // Only notify about player treaties
                        const otherPlayer = i === 0 ? j : i;
                        
                        if (treaties.peace) {
                            addDiplomaticMessage(`Peace treaty with ${gameState.players[otherPlayer].name} will expire next turn.`);
                        }
                        
                        if (treaties.alliance) {
                            addDiplomaticMessage(`Alliance with ${gameState.players[otherPlayer].name} will expire next turn.`);
                        }
                        
                        if (treaties.tradeAgreement) {
                            addDiplomaticMessage(`Trade agreement with ${gameState.players[otherPlayer].name} will expire next turn.`);
                        }
                    }
                }
                
                // Check for expired treaties
                if (treaties.expires > 0 && treaties.expires <= gameState.turn) {
                    // Treaty expired
                    treaties.peace = false;
                    treaties.alliance = false;
                    treaties.tradeAgreement = false;
                    treaties.expires = 0;
                    
                    if (i === 0 || j === 0) { // Only notify about player treaties
                        const otherPlayer = i === 0 ? j : i;
                        addDiplomaticMessage(`Treaties with ${gameState.players[otherPlayer].name} have expired.`);
                    }
                }
            }
        }
    }
    
    // AI diplomacy actions towards other AIs
    processDiplomacyBetweenAIs();
    
    // AI may initiate diplomacy with player
    for (let i = 1; i < gameState.players.length; i++) {
        if (!gameState.players[i].alive) continue;
        
        const treaties = gameState.diplomacy.treaties[i][0];
        const relations = gameState.diplomacy.relations[i][0];
        
        // If at war, AI might offer peace based on relative strength and relations
        if (!treaties.peace) {
            // Calculate AI's desire for peace based on relative military strength
            const playerStrength = calculateMilitaryStrength(0);
            const aiStrength = calculateMilitaryStrength(i);
            
            let peaceProbability = 0.1; // Base chance
            
            if (aiStrength < playerStrength * 0.8) {
                // AI is weaker, more likely to seek peace
                peaceProbability += 0.3;
            }
            
            if (relations > 30) {
                // Relations aren't terrible, more likely to seek peace
                peaceProbability += 0.2;
            }
            
            if (Math.random() < peaceProbability) {
                treaties.peace = true;
                gameState.diplomacy.treaties[0][i].peace = true;
                
                // Set expiration
                const expiration = gameState.turn + 10;
                treaties.expires = expiration;
                gameState.diplomacy.treaties[0][i].expires = expiration;
                
                // Improve relations
                gameState.diplomacy.relations[0][i] = Math.min(100, gameState.diplomacy.relations[0][i] + 10);
                gameState.diplomacy.relations[i][0] = Math.min(100, gameState.diplomacy.relations[i][0] + 10);
                
                addDiplomaticMessage(`${gameState.players[i].name} has offered a peace treaty, which you have accepted.`);
            }
        }
        // If at peace but not allies, AI might propose alliance
        else if (!treaties.alliance && relations > 70) {
            if (Math.random() < 0.2) {
                treaties.alliance = true;
                gameState.diplomacy.treaties[0][i].alliance = true;
                
                // Set expiration
                const expiration = gameState.turn + 15;
                treaties.expires = expiration;
                gameState.diplomacy.treaties[0][i].expires = expiration;
                
                // Improve relations
                gameState.diplomacy.relations[0][i] = Math.min(100, gameState.diplomacy.relations[0][i] + 20);
                gameState.diplomacy.relations[i][0] = Math.min(100, gameState.diplomacy.relations[i][0] + 20);
                
                addDiplomaticMessage(`${gameState.players[i].name} has proposed an alliance, which you have accepted.`);
            }
        }
    }
}

// Calculate military strength of a player
function calculateMilitaryStrength(playerId) {
    let strength = 0;
    
    // Count all military units
    for (let y = 0; y < 10; y++) {
        for (let x = 0; x < 10; x++) {
            const tile = gameState.tiles[y][x];
            
            // Add strength for each military unit
            for (const unit of tile.units) {
                if (unit.owner === playerId && unit.type !== 'settler') {
                    strength += unit.attack + unit.defense;
                }
            }
            
            // Add strength for cities (they provide defensive advantage)
            if (tile.isCity && tile.owner === playerId) {
                strength += 5;
            }
        }
    }
    
    return strength;
}

// Process diplomacy between AI players
function processDiplomacyBetweenAIs() {
    for (let i = 1; i < gameState.players.length; i++) {
        if (!gameState.players[i].alive) continue;
        
        for (let j = i + 1; j < gameState.players.length; j++) {
            if (!gameState.players[j].alive) continue;
            
            // Skip if they already have treaties
            if (gameState.diplomacy.treaties[i][j].peace) continue;
            
            // Calculate likelihood of peace based on relations
            const relations = gameState.diplomacy.relations[i][j];
            const peaceProbability = relations / 200; // Max 0.5 chance per turn
            
            if (Math.random() < peaceProbability) {
                // Establish peace treaty
                gameState.diplomacy.treaties[i][j].peace = true;
                gameState.diplomacy.treaties[j][i].peace = true;
                
                // Set expiration
                const expiration = gameState.turn + 10;
                gameState.diplomacy.treaties[i][j].expires = expiration;
                gameState.diplomacy.treaties[j][i].expires = expiration;
                
                // Improve relations
                gameState.diplomacy.relations[i][j] = Math.min(100, gameState.diplomacy.relations[i][j] + 10);
                gameState.diplomacy.relations[j][i] = Math.min(100, gameState.diplomacy.relations[j][i] + 10);
            }
        }
    }
}

// Update AI behavior based on diplomacy status
function updateAIBehavior() {
    // This function modifies the AI's behavior based on diplomatic status
    // Will be called by processAITurn
}

// Enhanced AI turn processing
function processEnhancedAITurn(playerId) {
    const player = gameState.players[playerId];
    
    if (!player.alive) return;
    
    // Collect AI resources (simplified)
    player.gold += 10;
    
    // Get diplomatic status with player
    const treatiesWithPlayer = gameState.diplomacy.treaties[playerId][0];
    const relationsWithPlayer = gameState.diplomacy.relations[playerId][0];
    
    // Find AI cities
    const aiCities = [];
    for (let y = 0; y < 10; y++) {
        for (let x = 0; x < 10; x++) {
            const tile = gameState.tiles[y][x];
            if (tile.isCity && tile.owner === playerId) {
                aiCities.push(tile);
            }
        }
    }
    
    // If AI has no cities, they're already defeated
    if (aiCities.length === 0) {
        player.alive = false;
        return;
    }
    
    // Find all AI units
    const aiUnits = [];
    for (let y = 0; y < 10; y++) {
        for (let x = 0; x < 10; x++) {
            const tile = gameState.tiles[y][x];
            for (const unit of tile.units) {
                if (unit.owner === playerId) {
                    aiUnits.push({ unit, tile });
                }
            }
        }
    }
    
    // Strategic decisions based on game state
    const strategy = determineAIStrategy(playerId, aiCities, aiUnits);
    
    // Train units if gold available
    if (player.gold >= 50 && aiCities.length > 0) {
        const randomCity = aiCities[Math.floor(Math.random() * aiCities.length)];
        
        // Unit training probability depends on strategy
        let trainingChance = 0.5; // Base chance
        
        if (strategy === 'expansion') trainingChance = 0.3; // Less focus on military
        if (strategy === 'defensive') trainingChance = 0.6; // More focus on defense
        if (strategy === 'offensive') trainingChance = 0.8; // Heavy focus on military
        
        if (Math.random() < trainingChance) {
            // Determine unit type based on strategy and gold
            let unitType = 'warrior';
            let unitCost = 50;
            
            // Prioritize settlers for expansion
            if (strategy === 'expansion' && player.gold >= 100 && Math.random() < 0.4) {
                unitType = 'settler';
                unitCost = 100;
            } 
            // Prioritize different unit types based on strategy
            else if (player.gold >= 100) {
                if (strategy === 'offensive') {
                    unitType = 'knight';
                    unitCost = 100;
                } else {
                    // Choose among various types
                    const types = ['warrior', 'archer', 'swordsman', 'knight'];
                    const costs = [50, 60, 80, 100];
                    
                    // Filter by affordable units
                    const affordableTypes = [];
                    const affordableCosts = [];
                    
                    for (let i = 0; i < types.length; i++) {
                        if (costs[i] <= player.gold) {
                            affordableTypes.push(types[i]);
                            affordableCosts.push(costs[i]);
                        }
                    }
                    
                    // Select random affordable unit
                    const randomIndex = Math.floor(Math.random() * affordableTypes.length);
                    unitType = affordableTypes[randomIndex];
                    unitCost = affordableCosts[randomIndex];
                }
            }
            
            // Create unit
            const unit = {
                type: unitType,
                owner: playerId,
                attack: getAttackValue(unitType),
                defense: getDefenseValue(unitType),
                moved: false,
                attacked: false
            };
            
            // Add unit to city
            randomCity.units.push(unit);
            player.gold -= unitCost;
            
            // Update UI
            updateUnitsUI(randomCity);
        }
    }
    
    // Process each unit's actions
    for (const aiUnit of aiUnits) {
        const { unit, tile } = aiUnit;
        
        // Skip units that already moved or attacked
        if (unit.moved || unit.attacked) continue;
        
        // Settler units should prioritize founding cities
        if (unit.type === 'settler') {
            processSettlerUnit(unit, tile, playerId);
        } 
        // Military units act based on diplomatic status
        else {
            processMilitaryUnit(unit, tile, playerId, treatiesWithPlayer, relationsWithPlayer, strategy);
        }
    }
}

// Determine AI strategy based on game state
function determineAIStrategy(playerId, aiCities, aiUnits) {
    // Default strategy
    let strategy = 'balanced';
    
    // Calculate military strength relative to player
    const playerStrength = calculateMilitaryStrength(0);
    const aiStrength = calculateMilitaryStrength(playerId);
    
    // Check diplomatic status with player
    const treatiesWithPlayer = gameState.diplomacy.treaties[playerId][0];
    const relationsWithPlayer = gameState.diplomacy.relations[playerId][0];
    
    // Calculate city and unit counts
    const playerCityCount = countPlayerCities(0);
    const aiCityCount = aiCities.length;
    
    // Determine strategy based on factors
    if (treatiesWithPlayer.peace || treatiesWithPlayer.alliance) {
        // At peace, focus on expansion
        if (aiCityCount < playerCityCount) {
            strategy = 'expansion';
        } else {
            strategy = 'balanced';
        }
    } else {
        // At war, choose strategy based on relative strength
        if (aiStrength < playerStrength * 0.7) {
            // Much weaker, focus on defense
            strategy = 'defensive';
        } else if (aiStrength > playerStrength * 1.2) {
            // Stronger, focus on offense
            strategy = 'offensive';
        } else {
            // Similar strength, balanced approach
            strategy = 'balanced';
        }
    }
    
    return strategy;
}

// Count cities owned by a player
function countPlayerCities(playerId) {
    let count = 0;
    
    for (let y = 0; y < 10; y++) {
        for (let x = 0; x < 10; x++) {
            const tile = gameState.tiles[y][x];
            if (tile.isCity && tile.owner === playerId) {
                count++;
            }
        }
    }
    
    return count;
}

// Process settler unit actions
function processSettlerUnit(unit, tile, playerId) {
    // Check if current tile is suitable for a city
    if (tile.type !== 'water' && tile.type !== 'mountain' && !tile.isCity) {
        // Look at surrounding tiles to evaluate location quality
        let locationScore = 0;
        
        const directions = [
            { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
            { x: -1, y: 0 }, /* center */ { x: 1, y: 0 },
            { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }
        ];
        
        for (const dir of directions) {
            const newX = tile.x + dir.x;
            const newY = tile.y + dir.y;
            
            if (newX >= 0 && newX < 10 && newY >= 0 && newY < 10) {
                const neighborTile = gameState.tiles[newY][newX];
                
                // Add score based on tile type
                if (neighborTile.type === 'grass') locationScore += 2;
                if (neighborTile.type === 'forest') locationScore += 1;
                if (neighborTile.type === 'desert') locationScore += 0.5;
                if (neighborTile.type === 'water') locationScore += 1; // Water is good for cities
                
                // Prefer not being too close to other cities
                if (neighborTile.isCity) locationScore -= 5;
            }
        }
        
        // If location is good enough, found a city
        if (locationScore >= 10) {
            // Found city
            foundAICity(tile, playerId, unit);
            return;
        }
    }
    
    // If we didn't found a city, move to find a better location
    moveSettlerTowardsBetterLocation(unit, tile, playerId);
}

// Found a city for AI
function foundAICity(tile, playerId, settler) {
    // Remove settler
    const settlerIndex = tile.units.indexOf(settler);
    if (settlerIndex !== -1) {
        tile.units.splice(settlerIndex, 1);
    }
    
    // Update UI
    updateUnitsUI(tile);
    
    // Mark as city
    tile.isCity = true;
    tile.owner = playerId;
    
    // Add city icon
    const cityIcon = document.createElement('div');
    cityIcon.classList.add('tile-building');
    cityIcon.style.backgroundImage = `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><rect x="2" y="10" width="20" height="12" fill="%23607D8B"/><rect x="4" y="6" width="16" height="4" fill="%2378909C"/><rect x="7" y="2" width="10" height="4" fill="%23B0BEC5"/><rect x="5" y="14" width="3" height="3" fill="%23CFD8DC"/><rect x="10" y="14" width="3" height="3" fill="%23CFD8DC"/><rect x="15" y="14" width="3" height="3" fill="%23CFD8DC"/><rect x="5" y="19" width="13" height="1" fill="%23B0BEC5"/></svg>')`;
    tile.element.appendChild(cityIcon);
    
    // Add owner color
    const ownerColor = document.createElement('div');
    ownerColor.classList.add('tile-owner');
    ownerColor.style.backgroundColor = gameState.players[playerId].color;
    tile.element.appendChild(ownerColor);
    
    // Claim adjacent tiles
    claimAdjacentTiles(tile.x, tile.y, playerId);
}

// Add diplomacy systems to game state
function initializeDiplomacySystem() {
    // Add diplomacy state to game
    gameState.diplomacy = {
        relations: {}, // Store relations between players
        treaties: {},  // Store active treaties
        messages: []   // Diplomatic messages/history
    };
    
    // Initialize relations between all players
    for (let i = 0; i < gameState.players.length; i++) {
        gameState.diplomacy.relations[i] = {};
        gameState.diplomacy.treaties[i] = {};
        
        for (let j = 0; j < gameState.players.length; j++) {
            if (i !== j) {
                // Initial relations are neutral (0 to 100 scale)
                gameState.diplomacy.relations[i][j] = 50;
                
                // No treaties initially
                gameState.diplomacy.treaties[i][j] = {
                    peace: false,
                    alliance: false,
                    tradeAgreement: false,
                    expires: 0
                };
            }
        }
    }
    
    // Add diplomatic actions UI
    addDiplomacyUI();
}

// Add diplomacy UI
function addDiplomacyUI() {
    // Create diplomacy button
    const diplomacyBtn = document.createElement('button');
    diplomacyBtn.id = 'diplomacy-btn';
    diplomacyBtn.textContent = 'Diplomacy';
    
    // Add to action buttons
    const actionButtons = document.querySelector('.action-buttons');
    actionButtons.appendChild(diplomacyBtn);
    
    // Add event listener
    diplomacyBtn.addEventListener('click', showDiplomacyPanel);
    
    // Create diplomacy panel (hidden initially)
    const diplomacyPanel = document.createElement('div');
    diplomacyPanel.id = 'diplomacy-panel';
    diplomacyPanel.className = 'tech-tree-panel';
    diplomacyPanel.style.display = 'none';
    
    // Add close button
    const closeButton = document.createElement('div');
    closeButton.className = 'close-button';
    closeButton.textContent = '✕';
    closeButton.addEventListener('click', () => {
        diplomacyPanel.style.display = 'none';
    });
    
    diplomacyPanel.appendChild(closeButton);
    
    // Add title
    const title = document.createElement('h2');
    title.className = 'panel-title';
    title.textContent = 'Diplomacy';
    diplomacyPanel.appendChild(title);
    
    // Add container for AI players
    const aiListContainer = document.createElement('div');
    aiListContainer.id = 'diplomacy-ai-list';
    diplomacyPanel.appendChild(aiListContainer);
    
    // Add to body
    document.body.appendChild(diplomacyPanel);
    
    // Add CSS for diplomacy UI
    const style = document.createElement('style');
    style.textContent = `
        #diplomacy-panel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 80%;
            background-color: var(--primary-color);
            border-radius: 8px;
            z-index: 20;
            padding: 1rem;
            overflow-y: auto;
        }
        
        .ai-diplomatic-status {
            background-color: var(--secondary-color);
            padding: 1rem;
            border-radius: 4px;
            margin-bottom: 1rem;
        }
        
        .diplomatic-action {
            margin: 0.5rem 0;
        }
        
        .relation-meter {
            height: 10px;
            width: 100%;
            background-color: #ccc;
            margin: 0.5rem 0;
            border-radius: 5px;
            overflow: hidden;
        }
        
        .relation-value {
            height: 100%;
            background: linear-gradient(to right, #e74c3c, #f1c40f, #2ecc71);
            transition: width 0.3s;
        }
        
        .treaty-status {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .treaty-badge {
            padding: 0.2rem 0.5rem;
            border-radius: 10px;
            font-size: 0.8rem;
            background-color: var(--accent-color);
        }
    `;
    document.head.appendChild(style);
}

// Move settler to find better city location
// Move settler to find better city location (continued)
function moveSettlerTowardsBetterLocation(unit, tile, playerId) {
    // Find best direction to move
    const directions = [
        { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
        { x: -1, y: 0 }, /* center */ { x: 1, y: 0 },
        { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }
    ];
    
    let bestScore = -Infinity;
    let bestDirection = null;
    
    for (const dir of directions) {
        if (dir.x === 0 && dir.y === 0) continue; // Skip center
        
        const newX = tile.x + dir.x;
        const newY = tile.y + dir.y;
        
        // Skip if outside bounds
        if (newX < 0 || newX >= 10 || newY < 0 || newY >= 10) continue;
        
        const targetTile = gameState.tiles[newY][newX];
        
        // Skip impassable tiles or tiles with units
        if (targetTile.type === 'water' || targetTile.type === 'mountain') continue;
        if (targetTile.isCity) continue;
        if (targetTile.units.length > 0) continue;
        
        // Evaluate location
        let score = 0;
        
        // Check surrounding tiles
        for (const surroundDir of directions) {
            const surroundX = newX + surroundDir.x;
            const surroundY = newY + surroundDir.y;
            
            if (surroundX >= 0 && surroundX < 10 && surroundY >= 0 && surroundY < 10) {
                const surroundTile = gameState.tiles[surroundY][surroundX];
                
                // Add score based on tile type
                if (surroundTile.type === 'grass') score += 2;
                if (surroundTile.type === 'forest') score += 1;
                if (surroundTile.type === 'desert') score += 0.5;
                if (surroundTile.type === 'water') score += 1;
                
                // Prefer not being too close to other cities
                if (surroundTile.isCity) score -= 5;
                
                // Prefer not being too close to enemy units
                if (surroundTile.units.some(u => u.owner !== playerId)) score -= 3;
            }
        }
        
        // Update best direction
        if (score > bestScore) {
            bestScore = score;
            bestDirection = dir;
        }
    }
    
    // Move in best direction if found
    if (bestDirection) {
        const targetX = tile.x + bestDirection.x;
        const targetY = tile.y + bestDirection.y;
        const targetTile = gameState.tiles[targetY][targetX];
        
        // Move unit
        const unitIndex = tile.units.indexOf(unit);
        if (unitIndex !== -1) {
            tile.units.splice(unitIndex, 1);
            unit.moved = true;
            targetTile.units.push(unit);
            
            // Update UI
            updateUnitsUI(tile);
            updateUnitsUI(targetTile);
        }
    }
}

// Process military unit actions
function processMilitaryUnit(unit, tile, playerId, treatiesWithPlayer, relationsWithPlayer, strategy) {
    // If we have an alliance with player, prioritize attacking other AIs
    if (treatiesWithPlayer.alliance) {
        processAllianceBehavior(unit, tile, playerId);
    }
    // If we have peace with player, focus on defending territory
    else if (treatiesWithPlayer.peace) {
        processPeaceBehavior(unit, tile, playerId, strategy);
    }
    // If at war with player, act based on strategy
    else {
        processWarBehavior(unit, tile, playerId, strategy);
    }
}

// Alliance behavior for military units
function processAllianceBehavior(unit, tile, playerId) {
    // Find other AI players who are at war with us
    const enemies = [];
    
    for (let i = 0; i < gameState.players.length; i++) {
        if (i !== playerId && i !== 0 && gameState.players[i].alive) {
            // Check if we're at war
            if (!gameState.diplomacy.treaties[playerId][i].peace) {
                enemies.push(i);
            }
        }
    }
    
    // If we have enemies, focus on attacking them
    if (enemies.length > 0) {
        const targetPlayerId = enemies[Math.floor(Math.random() * enemies.length)];
        
        // Find enemy units and cities
        const targets = [];
        
        for (let y = 0; y < 10; y++) {
            for (let x = 0; x < 10; x++) {
                const targetTile = gameState.tiles[y][x];
                
                // Check for enemy cities
                if (targetTile.isCity && targetTile.owner === targetPlayerId) {
                    targets.push(targetTile);
                }
                
                // Check for enemy units
                if (targetTile.units.some(u => u.owner === targetPlayerId)) {
                    targets.push(targetTile);
                }
            }
        }
        
        // Move towards closest target
        if (targets.length > 0) {
            moveUnitTowardsTarget(unit, tile, targets, playerId);
        } else {
            // No enemies found, patrol territory
            patrolTerritory(unit, tile, playerId);
        }
    } else {
        // No enemies, patrol territory
        patrolTerritory(unit, tile, playerId);
    }
}

// Peace behavior for military units
function processPeaceBehavior(unit, tile, playerId, strategy) {
    if (strategy === 'expansion') {
        // Guard settlers
        guardSettlers(unit, tile, playerId);
    } else if (strategy === 'defensive') {
        // Patrol territory
        patrolTerritory(unit, tile, playerId);
    } else {
        // Balanced approach - mix of guarding and patrolling
        if (Math.random() < 0.5) {
            guardSettlers(unit, tile, playerId);
        } else {
            patrolTerritory(unit, tile, playerId);
        }
    }
}

// War behavior for military units
function processWarBehavior(unit, tile, playerId, strategy) {
    if (strategy === 'offensive') {
        // Prioritize attacking player cities and units
        attackPlayerTargets(unit, tile, playerId);
    } else if (strategy === 'defensive') {
        // Focus on defending cities
        defendCities(unit, tile, playerId);
    } else {
        // Balanced approach
        if (Math.random() < 0.5) {
            attackPlayerTargets(unit, tile, playerId);
        } else {
            defendCities(unit, tile, playerId);
        }
    }
}

// Guard settler units
function guardSettlers(unit, tile, playerId) {
    // Find nearby settlers
    const settlers = [];
    
    for (let y = 0; y < 10; y++) {
        for (let x = 0; x < 10; x++) {
            const searchTile = gameState.tiles[y][x];
            
            for (const tileUnit of searchTile.units) {
                if (tileUnit.owner === playerId && tileUnit.type === 'settler') {
                    settlers.push(searchTile);
                    break;
                }
            }
        }
    }
    
    if (settlers.length > 0) {
        // Move towards closest settler
        moveUnitTowardsTarget(unit, tile, settlers, playerId);
    } else {
        // No settlers, patrol territory
        patrolTerritory(unit, tile, playerId);
    }
}

// Patrol territory
function patrolTerritory(unit, tile, playerId) {
    // Move randomly within territory
    const directions = [
        { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
        { x: -1, y: 0 }, /* center */ { x: 1, y: 0 },
        { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }
    ];
    
    // Shuffle directions for randomness
    for (let i = directions.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [directions[i], directions[j]] = [directions[j], directions[i]];
    }
    
    // Try each direction
    for (const dir of directions) {
        if (dir.x === 0 && dir.y === 0) continue; // Skip center
        
        const newX = tile.x + dir.x;
        const newY = tile.y + dir.y;
        
        // Skip if outside bounds
        if (newX < 0 || newX >= 10 || newY < 0 || newY >= 10) continue;
        
        const targetTile = gameState.tiles[newY][newX];
        
        // Skip impassable tiles
        if (targetTile.type === 'water' || targetTile.type === 'mountain') continue;
        
        // Prefer to stay in territory
        if (targetTile.owner !== playerId) continue;
        
        // Skip tiles with units
        if (targetTile.units.length > 0) continue;
        
        // Move unit
        const unitIndex = tile.units.indexOf(unit);
        if (unitIndex !== -1) {
            tile.units.splice(unitIndex, 1);
            unit.moved = true;
            targetTile.units.push(unit);
            
            // Update UI
            updateUnitsUI(tile);
            updateUnitsUI(targetTile);
            break;
        }
    }
}

// Attack player targets
function attackPlayerTargets(unit, tile, playerId) {
    // Find player cities and units
    const targets = [];
    
    for (let y = 0; y < 10; y++) {
        for (let x = 0; x < 10; x++) {
            const targetTile = gameState.tiles[y][x];
            
            // Check for player cities
            if (targetTile.isCity && targetTile.owner === 0) {
                targets.push(targetTile);
            }
            
            // Check for player units
            if (targetTile.units.some(u => u.owner === 0)) {
                targets.push(targetTile);
            }
        }
    }
    
    // Move towards closest target
    if (targets.length > 0) {
        moveUnitTowardsTarget(unit, tile, targets, playerId);
    } else {
        // No targets found, patrol territory
        patrolTerritory(unit, tile, playerId);
    }
}

// Defend cities
function defendCities(unit, tile, playerId) {
    // Find nearby cities
    const ownCities = [];
    
    for (let y = 0; y < 10; y++) {
        for (let x = 0; x < 10; x++) {
            const searchTile = gameState.tiles[y][x];
            
            if (searchTile.isCity && searchTile.owner === playerId) {
                ownCities.push(searchTile);
            }
        }
    }
    
    if (ownCities.length > 0) {
        // Move towards closest city
        moveUnitTowardsTarget(unit, tile, ownCities, playerId);
    } else {
        // No cities, patrol territory
        patrolTerritory(unit, tile, playerId);
    }
}

// Move unit towards closest target
function moveUnitTowardsTarget(unit, tile, targets, playerId) {
    if (targets.length === 0) return;
    
    // Find closest target
    let closestTarget = targets[0];
    let shortestDistance = calculateDistance(tile, closestTarget);
    
    for (let i = 1; i < targets.length; i++) {
        const distance = calculateDistance(tile, targets[i]);
        if (distance < shortestDistance) {
            shortestDistance = distance;
            closestTarget = targets[i];
        }
    }
    
    // If already adjacent to target, attack
    if (shortestDistance === 1) {
        // Check if target has enemy units or is an enemy city
        const hasEnemy = closestTarget.units.some(u => u.owner !== playerId) || 
                         (closestTarget.isCity && closestTarget.owner !== playerId);
        
        if (hasEnemy) {
            // Attack
            unit.attacked = true;
            
            // Simplified combat for AI units
            performAIAttack(unit, tile, closestTarget, playerId);
        }
    } else {
        // Move towards target
        // Calculate direction to move
        const dx = closestTarget.x - tile.x;
        const dy = closestTarget.y - tile.y;
        
        // Determine best move direction
        let moveX = 0;
        let moveY = 0;
        
        if (Math.abs(dx) > Math.abs(dy)) {
            // Move horizontally
            moveX = dx > 0 ? 1 : -1;
        } else {
            // Move vertically
            moveY = dy > 0 ? 1 : -1;
        }
        
        // Check target tile
        const newX = tile.x + moveX;
        const newY = tile.y + moveY;
        
        // Skip if outside bounds
        if (newX < 0 || newX >= 10 || newY < 0 || newY >= 10) return;
        
        const targetTile = gameState.tiles[newY][newX];
        
        // Skip water and mountain tiles
        if (targetTile.type === 'water' || targetTile.type === 'mountain') return;
        
        // Skip if tile has own units
        if (targetTile.units.some(u => u.owner === playerId)) return;
        
        // Skip enemy cities unless attacking
        if (targetTile.isCity && targetTile.owner !== playerId && targetTile.owner !== 0) return;
        
        // If target tile has enemy units, attack instead of moving
        if (targetTile.units.some(u => u.owner !== playerId)) {
            unit.attacked = true;
            performAIAttack(unit, tile, targetTile, playerId);
            return;
        }
        
        // Move unit
        const unitIndex = tile.units.indexOf(unit);
        if (unitIndex !== -1) {
            tile.units.splice(unitIndex, 1);
            unit.moved = true;
            targetTile.units.push(unit);
            
            // Update UI
            updateUnitsUI(tile);
            updateUnitsUI(targetTile);
        }
    }
}

// Calculate distance between two tiles
function calculateDistance(tileA, tileB) {
    return Math.abs(tileA.x - tileB.x) + Math.abs(tileA.y - tileB.y);
}

// Perform AI attack
function performAIAttack(unit, fromTile, toTile, playerId) {
    // Skip if unit has already attacked
    if (unit.attacked) return;
    
    // Calculate attack strength
    const attackStrength = unit.attack;
    
    // Calculate defense strength
    let defenseStrength = 0;
    let defendingUnit = null;
    
    if (toTile.units.length > 0) {
        // Find strongest defender
        for (const defender of toTile.units) {
            if (defender.owner !== playerId && defender.defense > defenseStrength) {
                defenseStrength = defender.defense;
                defendingUnit = defender;
            }
        }
    } else if (toTile.isCity) {
        // Cities have base defense
        defenseStrength = 3;
    }
    
    // Determine outcome (with some randomness)
    const attackRoll = Math.random() * 0.4 + 0.8; // 0.8 to 1.2
    const defenseRoll = Math.random() * 0.4 + 0.8; // 0.8 to 1.2
    
    const attackTotal = attackStrength * attackRoll;
    const defenseTotal = defenseStrength * defenseRoll;
    
    let message = '';
    
    if (attackTotal > defenseTotal) {
        // Attacker wins
        if (defendingUnit) {
            // Remove defender unit
            const unitIndex = toTile.units.indexOf(defendingUnit);
            toTile.units.splice(unitIndex, 1);
            updateUnitsUI(toTile);
            
            // Show message if attacking player unit
            if (defendingUnit.owner === 0) {
                message = `${gameState.players[playerId].name} has defeated your ${defendingUnit.type}!`;
            }
        } else if (toTile.isCity && toTile.owner !== playerId) {
            // Capture city
            const formerOwner = toTile.owner;
            toTile.owner = playerId;
            
            // Update city appearance
            for (const child of [...toTile.element.children]) {
                if (child.classList.contains('tile-owner')) {
                    child.style.backgroundColor = gameState.players[playerId].color;
                }
            }
            
            // Show message if capturing player city
            if (formerOwner === 0) {
                message = `${gameState.players[playerId].name} has captured your city!`;
            }
            
            // Check if player defeated
            checkPlayerDefeated(formerOwner);
        }
    }
    
    // Show message if relevant
    if (message) {
        showAlert(message);
    }
}

// Main function to add all diplomacy and AI improvements
function enhanceGameWithDiplomacyAndAI() {
    // Initialize diplomacy system
    initializeDiplomacySystem();
    
    // Add processing of diplomacy in end turn function
    const originalEndTurn = endTurn;
    endTurn = function() {
        // Process resources, research, etc.
        collectResources();
        processResearch();
        resetUnits();
        
        // Process diplomacy
        processDiplomacy();
        
        // Process enhanced AI turns
        for (let i = 1; i < gameState.players.length; i++) {
            if (gameState.players[i].alive) {
                processEnhancedAITurn(i);
            }
        }
        
        // Increment turn counter
        gameState.turn++;
        turnCounter.textContent = gameState.turn;
        
        // Update UI
        updateResourceDisplay();
        updateActionButtons();
        
        // Make sure we're not still in move or attack mode
        if (gameState.moveState) cancelMove();
        if (gameState.attackState) cancelAttack();
    };
    
    // Update UI
    updateGraphicsAndUI();
}

// Function to enhance graphics and UI
function updateGraphicsAndUI() {
    // Add tile textures and improved graphics
    enhanceTileGraphics();
    
    // Update CSS for better visuals
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        .game-map {
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }
        
        .tile:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
            z-index: 10;
        }
        
        .tile.selected {
            border: 2px solid gold;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.7);
        }
        
        button {
            transition: all 0.2s;
            border-radius: 6px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .alert {
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            animation: alertAppear 0.3s ease-out;
        }
        
        @keyframes alertAppear {
            from { opacity: 0; transform: translateX(-50%) translateY(-20px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
    `;
    document.head.appendChild(styleElement);
}

// Call this function during initialization
function initGameImprovements() {
    enhanceGameWithDiplomacyAndAI();
}
        
        // Reset game
        function resetGame() {
            // Reset game state
            gameState.turn = 1;
            gameState.selectedTile = null;
            gameState.tiles = [];
            gameState.players = [
                { id: 0, name: "Player", color: "#e74c3c", gold: 100, food: 0, production: 0, science: 0, alive: true },
                { id: 1, name: "AI 1", color: "#3498db", gold: 100, food: 0, production: 0, science: 0, alive: true },
                { id: 2, name: "AI 2", color: "#2ecc71", gold: 100, food: 0, production: 0, science: 0, alive: true }
            ];
            gameState.currentPlayer = 0;
            gameState.currentResearch = null;
            gameState.sciencePoints = 0;
            gameState.stats = {
                citiesBuilt: 0,
                unitsTrained: 0,
                enemiesDefeated: 0
            };
            gameState.moveState = null;
            gameState.attackState = null;
            
            // Reset technologies
            gameState.technologies = [
                { id: 0, name: "Agriculture", cost: 20, unlocks: ["Farm"], dependencies: [], researched: true, description: "Enables farm buildings" },
                { id: 1, name: "Mining", cost: 20, unlocks: ["Mine"], dependencies: [], researched: true, description: "Enables mine buildings" },
                { id: 2, name: "Writing", cost: 30, unlocks: ["Library"], dependencies: [], researched: true, description: "Enables library buildings" },
                { id: 3, name: "Currency", cost: 40, unlocks: ["Market"], dependencies: [1], researched: false, description: "Enables market buildings" },
                { id: 4, name: "Bronze Working", cost: 40, unlocks: ["Swordsman"], dependencies: [1], researched: false, description: "Enables training swordsmen" },
                { id: 5, name: "Mathematics", cost: 60, unlocks: ["Archer"], dependencies: [2], researched: false, description: "Enables training archers" },
                { id: 6, name: "Iron Working", cost: 80, unlocks: ["Barracks"], dependencies: [4], researched: false, description: "Enables barracks buildings" },
                { id: 7, name: "Horseback Riding", cost: 100, unlocks: ["Knight"], dependencies: [4], researched: false, description: "Enables training knights" }
            ];
            
            // Reset UI
            turnCounter.textContent = gameState.turn;
            
            // Reinitialize game
            initializeGame();
        }
        
        // Initialize the game
        initializeGame();
        // Inside your initializeGame function, add this at the end
        initGameImprovements();
        
    </script>
</body>
</html>

            